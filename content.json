[{"title":"阿里面试回来，想和Java程序员谈一谈","date":"2017-04-15T15:33:18.000Z","path":"2017/04/15/阿里面试回来，想和Java程序员谈一谈/","text":"引言其实本来真的没打算写这篇文章，主要是LZ得记忆力不是很好，不像一些记忆力强的人，面试完以后，几乎能把自己和面试官的对话都给记下来。LZ自己当初面试完以后，除了记住一些聊过的知识点以外，具体的内容基本上忘得一干二净，所以写这篇文章其实是很有难度的。但是，最近问LZ的人实在是太多了，为了避免重复回答，给自己省点力气，干脆就在这里统一回复了。 其实之前LZ写过一篇文章，但是那篇文章更多的是在讨论“面试前该不该刷题”这个话题，而这篇文章将会更加聚焦在面试前如何准备，以及工作当中如何学习这个话题上，而且会尽量写出一些干货。 第一个问题：阿里面试都问什么？这个是让LZ最头疼的一个问题，也是群里的猿友们问的最多的一个问题。 说实话，LZ只能隐约想起并发、JVM、分布式、TCP/IP协议这些个关键字，具体的问题真的是几乎都没记住。而且就算LZ记住了，也告诉你了，你也背会了，但LZ觉得，在面试中，你被问到一模一样问题的可能性依然很小。 甚至，就算你运气好被问到了，你也照着背下来了，也不一定就能对你的面试起到正面的作用，因为面试官万一多问一句，你可能就露馅了，那还不如干脆点说不会更好。 LZ参加的是阿里的社招面试，而社招不同于校招，问题的范围其实是很随机的。因为能参加一些比较知名的互联网公司社招的人，70%以上都会有个3-5年的经验。这倒不是说一两年经验的同学没有机会进这些公司，而是因为这种公司，大部分情况下只招一些比较资深的开发和应届生，而不招那些处于中间阶段的人。而1-2年经验的同学，往往就刚好处于这个尴尬的阶段。 对于能有3-5年经验的这部分人中，每个人的经历又都不同，所擅长的点也不一样，因此这就会导致每个人的问题和范围都不太一样。 很少说有哪个知名的互联网公司，比如BAT、京东、360、搜狐、网易等这些公司，其社招面试还有固定的问题和模式，让你可以像应届生面试一样，在面试前靠临时抱佛脚度过这一关。 大部分公司在社招的时候，不光是阿里，其它公司也都一样（因为LZ在一年多前也参加过很多其它知名互联网公司的面试，详情见《记录2015年年初跳槽的经历！》），基本上都分为两个阶段的提问。 第一个阶段是主语言本身以及它的高级特性，第二个阶段是讲述自己的项目，并在中间穿插着问题。 所以，LZ不妨就这两个阶段，谈谈社招面试的准备，而不是去把阿里面试的过程背一遍。说实话，LZ也确实记不住，所以不要再问LZ阿里面试都会问哪些问题了，你看看上面那个连接里的文章，也会发现，LZ里面也基本上没有写具体的问题，原因是一样的，真的记不住啊。（就是因为记忆力的问题，导致LZ从小偏科，文科成绩一直堪忧) 社招面试如何准备LZ会分为四个部分来谈论这个问题，由于LZ本身是Java出身，因此关于主语言的问题，都是与Java相关，其它语言的同学可以选择性忽略。此外，面试的时候一般面试官的问题都是环环相扣，逐渐深入的，这点在下面大家可以更明显的感受出来。 1、主语言本身以及它的高级特性。 主语言当然就是你平日里拿来赚钱的家伙。不要告诉LZ你没有主语言，你会N多种语言，或者是你精通N多种语言，你要非这么说的话，你可以来杭州试试，LZ保证不打死你，最多打残。 LZ的主语言很显然是Java，那么对于Java来说，它的语言本身以及它的高级特性，都有哪些比较容易在面试中问到呢？ 一般情况下，主要有以下知识点很容易被问到。（PS：以下所列举的，都是一些Java相对而言比较高级一点的知识点，因为这里谈的是社招，而不是校招） 1）Java的数据结构相关的类实现原理，比如LinkedList，ArrayList，HashMap，TreeMap这一类的。以下简单模拟一个数据结构的连环炮。比如，面试官先问你HashMap是不是有序的？ 你肯定回答说，不是有序的。那面试官就会继续问你，有没有有顺序的Map实现类？ 你如果这个时候说不知道的话，那这个问题就到此结束了。如果你说有TreeMap和LinkedHashMap。 那么面试官接下来就可能会问你，TreeMap和LinkedHashMap是如何保证它的顺序的？ 如果你回答不上来，那么到此为止。如果你依然回答上来了，那么面试官还会继续问你，你觉得它们两个哪个的有序实现比较好？ 如果你依然可以回答的话，那么面试官会继续问你，你觉得还有没有比它更好或者更高效的实现方式？ 如果你还能说出来的话，那么就你所说的实现方式肯定依然可以问你很多问题。 以上就是一个面试官一步一步提问的例子。所以，如果你了解的不多，千万不要敷衍，因为可能下一个问题你就暴露了，还不如直接说不会，把这个问题结束掉，赶紧切换到你熟悉的领域。 2）Java并发包当中的类，它们都有哪些作用，以及它们的实现原理，这些类就是java.concurrent包下面的。与上面一样，咱们也简单的模拟一个并发包的连环炮。比如面试官可能会先问你，如果想实现所有的线程一起等待某个事件的发生，当某个事件发生时，所有线程一起开始往下执行的话，有什么好的办法吗？ 这个时候你可能会说可以用栅栏（Java的并发包中的CyclicBarrier），那么面试官就会继续问你，你知道它的实现原理吗？ 如果你继续回答的话，面试官可能会继续问你，你还知道其它的实现方式吗？ 如果你还能说出很多种实现方式的话，那么继续问你，你觉得这些方式里哪个方式更好？ 如果你说出来某一个方式比较好的话，面试官依然可以继续问你，那如果让你来写的话，你觉得还有比它更好的实现方式吗？ 如果你这个时候依然可以说出来你自己更好的实现方式，那么面试官肯定还会揪着这个继续问你。 为什么说面试的时候要引导面试官，原因就在这了。因为面试官的提问很多时候都是有迹可循的，你如果抓住了他的轨迹，能够猜到他下面很可能会问什么，那你在回答的时候就可以往你想要谈的方向去说。这样面试时就会显得更加从容，更加的游刃有余。 3）IO包和NIO包中的内容。这部分里面NIO会是重点，IO包大部分都会比较熟悉，因此可能会直接略过，直接问你NIO的内容。IO包和NIO包的内容相对来说不是很多，首先NIO模型要熟悉，特别是其中的selector一定要非常清楚它的职责和实现原理。其实NIO的核心是IO线程池，一定要记住这个关键点。有的时候，面试官可能也会问你IO包的设计模式（装饰器模式），为什么要这样设计？ 有的面试官还会问你有没有更好的设计，这个时候如果你不知道请果断说自己现在的水平有限，想不出来更好的设计，千万不要信口开河，随意YY。 4）Java的虚拟机的内容。这部分主要包括三部分，GC、类加载机制，以及内存。一个GC部分简单的连环炮。 面试官可以先问你什么时候一个对象会被GC？ 接着继续问你为什么要在这种时候对象才会被GC？ 接着继续问你GC策略都有哪些分类？ 你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？ 你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？ 你如果选出来了，继续问你，为什么要选择这个策略？ 下面是关于类加载机制的简单连环炮。 首先肯定是先问你Java的类加载器都有哪些？ 回答了这些以后，可能会问你每个类加载器都加载哪些类？ 说完以后，可能会问你这些类加载之间的父子关系是怎样的？ 你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？ 你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？ 你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？ 再来一个关于内存的连环炮。 首先肯定就是问你内存分为哪几部分，这些部分分别都存储哪些数据？ 然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？ 接着可能会问你，内存的哪些部分会参与GC的回收？ 完事以后，可能还会问你Java的内存模型是怎么设计的？ 你回答了以后，还会继续问你为什么要这么设计？ 问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？ 你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。 基本上Java语言本身以及语言稍微高级点的内容就是以上部分，如果你能把以上四部分了解的非常透彻，那基本上Java这部分就没啥问题了，因为光以上的内容就够你跟面试官聊很久了。你聊这些聊得久了，自然问你其它问题的时间就会短点。 你从LZ写这些问题的过程也应该能感受出来，很多时候，面试官都是顺着一条线一路问下去的，如果你觉得这条线你不熟悉的话，就要及时拐弯，引导面试官去问其它方面的问题。千万不要一直往下深入，直到自己跳不出来为止，那就尴了个尬了。 2、讲述自己的项目，并在中间穿插着问题这一部分是面试过程中必问，也是聊得最久的一个阶段。除非你前面的语言部分非常扎实，扎实到面试官问了一两个小时，依旧没有探出你对语言本身的了解到底有多深。否则的话，你一定逃不过自己的项目这一关，而且一般情况下聊得时间不会太短。 这一部分内容，一般的模式就是你自己去讲你做过的项目，然后面试官会冷不丁的让你去解释其中某一部分，比如让你解释当时为什么要这么做，或者问你现在觉得有没有更好的办法。而这些穿插的问题，大部分与你的项目所用到的技术有关。而你需要做的，就是充分、再充分的去总结自己做过的项目（尤其是最近的一两个项目），挖掘出一个甚至N个亮点，以备于到时候可以让面试官产生眼前一亮的感觉。如果你能达到这种效果的话，基本上离你成功就不远了。 这部分内容由于和每个人自己的经历息息相关，因此这里也没法列举可能问到的问题。这篇文章《程序员面经：面试前到底该不该刷题以及面试前该如何准备》是LZ之前写的，里面大概讨论了下如何在面试前总结，有兴趣的可以去了解一下。 3、额外的加分项上面两个阶段基本上是必问的，还有一些加分项。这些加分项中，有些内容面试官也会问你（比如TCP/IP协议、算法），但更多的是会先问你了解不了解，你了解的话再继续聊，不了解的话就直接略过了，不至于因为这种问题而直接把你打入地狱。 下面LZ列举一下这些加分项，如果可以的话，这些加分项还是要争取一下的。 1、计算机系统原理。 2、网络通信协议（TCP/IP，HTTP等）。 3、数据结构与算法。 4、著名开源项目的源码。 5、你自己有很棒的开源项目。 6、你的个人博客。 7、待评论区补充。 这几项当中，对于前1-3项，如果你之前就比较了解，只是由于时间问题忘记了的话，还是可以临时抱佛脚一下的。至于后面4-6项，就需要你日常的积累了，不是一时半会儿能做到的。如果你平日里没有积累，那么后面这三个加分项只能抛弃了。 4、与你职位相关的内容其实这最后一项是对前面三项的补充，你应该尽量去主攻和你面试的职位相关的内容。比如你面试一个实时计算的职位，那么你的算法最好要厉害，对于著名的实时计算开源项目要熟悉，最好阅读过源码，而且还要对分布式系统有一定的见解。 因此，这个第4部分没有具体的内容，只是提醒你，如果你很明确自己的面试职位，最好在面试前准备的时候，尽量朝职位的需求方向靠拢，这样成功的可能性更大。 对于Java程序猿学习的建议这一部分其实也算是今天的重点，这一部分用来回答很多群里的朋友所问过的问题，那就是LZ你是如何学习Java的，能不能给点建议？ 今天LZ是打算来点干货，因此咱们就不说一些学习方法和技巧了，直接来谈每个阶段要学习的内容甚至是一些书籍。这一部分的内容，同样适用于一些希望转行到Java的同学。 在大家看之前，LZ要先声明两点。 1、由于LZ本人是Java后端开发出身，因此所推荐的学习内容是Java Web和Java后端开发的路线，非Java Web和Java后端开发的同学请适当参考其学习思想即可，切勿照搬。 2、下面对于【第一部分】的推荐内容，目的是让你尽快成为一个可以参加工作的Java开发者，更适用于处于待业状态，准备转行Java的同学。如果你是在校学生，务必要在学好基础（比如计算机系统、算法、编译原理等等）的前提下，再考虑去进行下面的学习。 第一部分：对于尚未做过Java工作的同学，包括一些在校生以及刚准备转行Java的同学。 一、Java基础首先去找一个Java的基础教程学一下，这里可以推荐一个地址，或者你也可以参照这个地址上去找相应的视频，地址为http://www.runoob.com/java/java-tutorial.html。 学习Java基础的时候，应该尽量多动手，很多时候，你想当然的事情，等你写出来运行一下，你就会发现不是这么回事儿，不信你就试试。 学完以上内容以后，你应该对Java有一个基本的了解了，你可以用Java语言写出一些简单的程序，并且你用的是最简单的编辑器，比如记事本。 这个时候，不要急于进入下一部分，留下几天好好写一些程序，尽可能熟悉这些基础内容。 二、Web开发等你写上几天程序以后，你往往会比较迷茫，因为你写的东西似乎看起来毫无用处，比如实现一个简单的计算器，读取一个文件等。这个时候你就应该去学着写一些让你觉得有意思的东西了，所以你应该学习更多的知识。 这些内容主要是Web开发相关的内容，包括HTML/CSS/JS（前端页面）、Servlet/JSP（J2EE）以及Mysql（数据库）相关的知识。 它们的学习顺序应该是从前到后，因此最先学习的应该是HTML/CSS/JS（前端页面），这部分内容你可以去上面的那个runoob网站上找。你可以试着自己写一些页面，当然，你可以尽你最大的努力让它变得最漂亮。这部分内容对于后端Java来说，理论上不是特别重要，但至少要达到可以自己写出一些简单页面的水平。 接下来，你需要学习的是Servlet/JSP（J2EE）部分，这部分是Java后端开发必须非常精通的部分，因此这部分是这三部分中最需要花精力的，而且这个时候，你要学会使用开发工具，而不能再使用记事本了，可以选择eclipse。 当你下载安装好eclipse以后，请视频中的教程一步一步去学习，一定要多动手。关于Servlet/Jsp部分视频的选择，业界比较认可马士兵的视频，因此推荐给大家。当然了，LZ本人并没有看过他的视频，所以不好说的太绝对，如果大家自己有更好的选择，可以坚持自己的，不要被LZ干扰。 原本LZ也是打算出教学视频的，但是由于时间问题，还是决定放弃了。但是如果你看视频的过程中遇到了问题，欢迎来LZ的交流群提问，或者去斗鱼观看LZ的直播提出你的问题，直播地址和群号都在LZ的个人博客左侧。 最后一步，你需要学会使用数据库，mysql是个不错的入门选择，而且Java领域里主流的关系型数据库就是mysql。这部分一般在你学习Servlet/Jsp的时候，就会接触到的，其中的JDBC部分就是数据库相关的部分。你不仅要学会使用JDBC操作数据库，还要学会使用数据库客户端工具，比如navicat，sqlyog，二选一即可。 三、开发框架当你学会以上内容以后，这个时候你还不足以参加工作，你还需要继续深造。公司里为了提高开发的效率，会使用一些Java Web框架，因此你还需要学习一些开发框架。 目前比较主流的是SSM框架，即spring、springmvc、mybatis。你需要学会这三个框架的搭建，并用它们做出一个简单的增删改查的Web项目。你可以不理解那些配置都是什么含义，以及为什么要这么做，这些留着后面你去了解。但你一定要可以快速的利用它们三个搭建出一个Web框架，你可以记录下你第一次搭建的过程，相信我，你一定会用到的。 还要提一句的是，你在搭建SSM的过程中，可能会经常接触到一个叫maven的工具。这个工具也是你以后工作当中几乎是必须要使用的工具，所以你在搭建SSM的过程中，也可以顺便了解一下maven的知识。在你目前这个阶段，你只需要在网络上了解一下maven基本的使用方法即可，一些高端的用法随着你工作经验的增加，会逐渐接触到的。 关于学习SSM框架的地址给大家推荐一个，这里面有视频，大家可以去观看，地址是http://edu.51cto.com/lesson/id-76468.html。 四、找工作当你完成开发框架的学习以后，你就该找工作了，在校的找实习，毕业的找全职。与此同时，在找工作的同时，你不应该停下你的学习，准确的说，是你在以后都不能停下学习。 上面这些内容你只是囫囵吞枣的学会了使用，你可以逐步尝试着去了解更多的东西，网络是你最重要的老师。 第一部分：对于参加工作一年以内的同学。恭喜你，这个时候，你已经拥有了一份Java的工作。这个阶段是你成长极快的阶段，而且你可能会经常加班。 但是加班不代表你就可以松懈了，永远记得LZ说的那句话，从你入行那一刻起，你就要不停的学习。在这一年里，你至少需要看完《Java编程思想》这本书。这本书的内容是帮助你对于Java有一个更加深入的了解，是Java基础的升级版。 这本书很厚，当初看这本书，LZ花了整整三个月。正常速度的话，应该可以在半年左右看完。LZ这里不要求过高，只要你在一年以内把这本书看完即可。当然了，LZ所说的看完，是充分吸收，而不是读一遍就完事了，因此有些内容你可能会看不止一遍。 总而言之，这个阶段的核心学习思想就是，在工作中实践，并且更加深入的了解Java基础。 第二部分：对于参加工作1年到2年的同学。这部分时间段的同学，已经对Java有了一个更加深入的了解。但是对于面向对象的体会可能还不够深刻，编程的时候还停留在完成功能的层次，很少会去考虑设计的问题。 于是这个时候，设计模式就来了。LZ当时看的是《大话设计模式》这本书，并且写了完整版的设计模式博客。因此，LZ要求大家，最多在你工作一年的时候，必须开始写博客，而设计模式就是你博客的开端。 请记住，LZ所提的基本都是最低要求，因此不要有任何松懈的心理，否则五年后，你不要去羡慕别人高于你的工资，也不要去羡慕别人进入了某公司。 这一年，你必须对于设计模式了如指掌，《大话设计模式》可以作为你的开端。当然了，你也可以去看LZ的个人博客去学习，地址是http://www.cnblogs.com/zuoxiaolong/p/pattern26.html。 此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。比如《重构 改善既有代码的设计》，《Effective Java》。 总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。 第三部分：对于参加工作2年到3年的同学有的同学在这个时候觉得自己已经很牛逼了，于是忍不住开始慢慢松懈。请记住，你还嫩的多。 这个阶段，有一本书是你必须看的，它叫做《深入理解Java虚拟机》。这本书绝对是Java开发者最重要的书，没有之一。在LZ眼里，这本书的重要性还要高于《Java编程思想》。 这本书的内容是帮助你全面的了解Java虚拟机，在这个阶段，你一定已经知道Java是运行在JVM之上的。所以，对于JVM，你没有任何理由不了解它。LZ之前有写过JVM系列的知识，可以去看一下，地址是http://www.cnblogs.com/zuoxiaolong/category/508918.html。 另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，而这部分内容，LZ比较推荐《Java并发编程实战》这本书。只要你把这本书啃下来了，并发的部分基本已经了解了十之六七。 与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。因此，你需要去看一些JDK中的类的源码，也包括你所使用的框架的源码。 这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写？为什么要定义这个接口，它看起来好像很多余？ 由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且LZ很负责的告诉你，LZ在这个阶段的时候，所学习的东西远多于这里所罗列出来的。因此千万不要觉得你已经学的很多了，LZ所说的这些都只是最低要求，不光是LZ，很多人在这个时间段所学习的内容都远超本文的范围。 如果你不能跟上节奏的话，若干年后，如果不是程序猿市场还不错的话，你很可能不仅仅是工资比别人低，公司没别人好，而是根本就找不到工作。 总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库（比如并发那本书就是Java并发包java.concurrent的内容），也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。 另外，还有一种学习的方式，在2年这个阶段，也应该启用了，那就是造轮子。 不要听信那套“不要重复造轮子”的论调，那是公司为了节省时间成本编造出来的。重复造轮子或许对别人没有价值，因为你造的轮子可能早就有了，而且一般情况下你造出来的轮子还没有现存的好。但是对别人没有价值，不代表对你自己没有价值。 一个造轮子的过程，是一个从无到有的过程。这个过程可以对你进行系统的锻炼，它不仅考察你的编码能力，还考察你的框架设计能力，你需要让你的轮子拥有足够好的扩展性、健壮性。 而且在造轮子的过程中，你会遇到各种各样的难题，这些难题往往又是你学习的契机。当你把轮子造好的时候，你一定会发现，其实你自己收获了很多。 所以，这个阶段，除了上面提到的了解JVM、JDK和框架源码以外，也请你根据别人优秀的源码，去造一个任何你能够想象出来的轮子。 第四部分：参加工作3年到4年的同学这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。 因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。 而且在研究一门新技术时，切忌朝三暮四。有的同学今天去整整大数据，搞搞Hadoop、hbase一类的东西。过不了一段时间，就觉得没意思，又去研究分布式缓存，比如redis。然后又过不了一段时间，又去研究分布式计算，比如整整Mapreduce或者storm。 结果到最后，搞得自己好像什么都会一样，在简历上大言不惭的写上大数据、分布式缓存、分布式计算都了解，其实任何一个都只是浮于表面。到时候面试官随便一问，就把你给识破了。 一定要记住，作为一个程序猿，平日里所接触的技术可能会很多，但是想要让一门技术成为你的优势，那么一定是你对这门技术的了解强过绝大多数人才行。 因此在这个阶段，你就不能再简单的去学习前3年的内容了，虽然前面的学习如果还不够深入的话依旧要继续，但这个时候你应该更多的考虑建立你的优势，也可以称为差异性。 差异性相信不难理解，就是让你自己变得与众不同。你前面三年的学习足够你成为一名基本合格的Java开发者，但你离成为一名优秀的Java开发者还有很大的距离。 所谓优秀，即能别人所不能。而你前三年所学习的内容，是很多做过几年的Java开发都能够掌握的。那么为了让自己有差异性，你就需要另辟蹊径，找一个方向深入研究下去，以期在将来，你能够成为这个领域的专家，比如分布式计算领域的专家，大数据领域的专家，并发领域的专家等等。 此外，你除了建立你的差异性之外，还要去弥补你基础上的不足，直到现在，LZ都没有提及基础知识。原因是基础是很枯燥无味的，学的太早不仅容易懵逼，而且懵逼的同时还容易产生心理阴影，以至于以后再不想去研究这些基础。但基础又是你深入研究一些领域时所必须掌握的，比如你去研究分布式计算，你不懂算法你玩个毛毛？比如你去做分布式缓存，你对计算机系统的内存不了解，你如何去做缓存？ 如果你的基础本来就非常强，那么恭喜你，相信你在之前的工作中已经充分体会到了这些基础对你的帮助。但LZ相信大部分人的基础都很薄弱，哪怕是科班毕业的人，很多人也不敢说自己当初的基础学的多么强大，比如算法、计算机系统原理、编译原理这些。 但是每个人时间都是有限的，而且这些基础的书籍每一本读下来，没个一年半载的，还真拿不下来，因此还是要有所抉择的。虽然艺多不压身，但问题是艺多是有代价的，是需要你付出时间和精力的，而LZ个人更赞成在同等代价的情况下获取最大的收获。 首先，LZ比较推崇的基础书籍有三本，分别是《深入理解计算机系统》，《tcp/ip详解 卷一、二、三》，《数据结构与算法》。其中TCP/IP有三本书，但我们这里把这三本看成是一本大书。 这三本分别适合三种人，《深入理解计算机系统》比较适合一直从事Java Web开发和APP后端开发工作的人群。《tcp/ip详解 卷一、二、三》比较适合做网络编程的人群，比如你使用netty去开发的话，那么就要对TCP/IP有更深入的了解。而《数据结构与算法》这本书，则比较适合做计算研究工作的人，比如刚才提到的分布式计算。 另外，LZ要强调的是，这里所说的适合，并不是其它两本对你就没有用。比如你做Java Web和APP后端开发，《tcp/ip详解 卷一、二、三》这本书对你的作用也是很大的。这里只是分出个主次关系而已，你要是时间足够的话，能把三本都精读那当然最好不过了。但如果时间有限的话，那么就先挑对你帮助最大的书去读。 理论上来讲，这一年你能把这三本其中一本精读下来，就已经非常厉害了。有了基础，有了前面的工作经验，你就可以去开拓属于你的领域了。 在这一年里，一定要规划好自己的领域，建立好自己的优势，制造出差异性。如果你对自己的领域不够清晰的话，随着你工作的时间日益增多，你接触的技术会越来越多，这个时候，你很容易被淹死在技术的海洋里，看似接触的技术越来越多，会用的也越来越多，但你毫无优势。 有的同学可能会问，“LZ，我也不知道我的领域是什么啊？怎么办呢？” 对于这种人，LZ只想说，“卧槽，这还问我？要不干脆我替你学习得了，好不好？” 第五部分：参加工作4年到5年的同学经过前面一年的历练，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。 这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去Github创建一个属于你的开源项目，去打造自己的产品。这次的开源项目不同于之前的造轮子，你这个时候是真的要去尽量尝试造出来真正对别人有价值的轮子。 技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。 这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。程序猿在某种程度上和明星很像，一个好的电视剧和电影就可以成就一批明星，程序猿有的时候也是，一个好的项目就可以成就一群程序猿。 比如国内几个脍炙人口的项目，像淘宝、支付宝、QQ、百度、微信等等。这每一个项目，都成就了一批程序猿。LZ敢说，这里面任何一个项目，如果你是它的核心开发，光是这样一个Title，就已经是你非常大的优势。更何况还不止如此，Title说到底也是个名头，更重要的是，这种项目在做的时候，对你的历练一定也是非常给力的。 而你如果想要参与这样的项目，除了靠运气之外，影响力也是很重要的一个手段。比如你在分布式计算领域有一定的影响力，那么如果有什么好的关于分布式计算的项目，对方就很可能会邀请你。就算人家不邀请你，你自己主动去面试的时候，对方如果知道你在这个领域的影响力，也肯定会起到很大的作用，而这个作用，甚至可能会超过你现在的技术能力。 所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。如果你能够靠你的影响力和以前积累的技术，参与到一个伟大的项目当中，那么你后面的五年也就有着落了。 当然了，LZ现在满打满算，做程序猿也就4年半不到，因此关于4年到5年这一部分，LZ的见解不一定是对的，就算是对的，也不一定是适合任何人的。所以，希望大家自己有的判断力，去决定到底该如何度过这一年。结语 本文到此就基本结束了，整篇文章很长，但其实主要就说了两部分内容，一个是社招面试的准备，一个是Java生涯的学习。 关于这两部分，LZ已经给出了自己的见解，但是还是那句话，每个人吸收知识的时候，都要有抽取精华，去除糟粕的能力。LZ所说的，可能有些是对的，有些是错的，有些是适合你的，有些是不太适合你的，你要自己能够判断。 其实你在生活和工作当中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你很讨厌。但其实你喜欢的人也有缺点，你讨厌的人也有优点。你要学会从你讨厌的人身上学会他的优点，千万不要一棒子打死，这只会让你失去很多学习成长的机会。 好了，说了这么多了，就到此为止吧，希望本文可以帮助到作为程序猿或即将成为程序猿的你。 最后，如果你对阿里巴巴技术感兴趣，希望到阿里巴巴平台上从事技术相关的岗位，可以试试这里：]招聘帖 转自：http://www.jianshu.com/p/5681a1f0aad6","tags":[{"name":"面试","slug":"面试","permalink":"http://willxue.top/tags/面试/"}]},{"title":"哈佛幸福课","date":"2017-04-10T03:59:03.000Z","path":"2017/04/10/哈佛幸福课/","text":"哈佛幸福课整理作者：Gill链接：https://www.zhihu.com/question/22437266/answer/42237297来源：知乎著作权归作者所有，转载请联系作者获得授权。 花了一个月时间（7月中旬~8月中旬）看完了23堂哈佛大学公开课——幸福课。每个工作日一课，如免费的远程教育。大约看到第二集就忍不住大赞，并开始向小伙伴们推荐。每天饶有兴趣地等待Tal展开新的话题，获得改变心态的新思路。我想说，真的有用。It works! 转载: https://www.zhihu.com/question/22437266 鉴于小伙伴们反馈无法耐心观看，我便萌生了整理幸福课笔记，分享给大家的念头。就这样，我又花了半个月时间温习了一遍幸福课。 停止妄念 Commonsense is not that common以为听了幸福课或看了我这篇文章就能幸福的人，请停止妄念。你以为我们坐下来好好谈谈，然后就能过上幸福快乐的生活了吗？道理什么的“听听都懂”，甚至可以说是老生常谈，但你有真正尝试过“那些建议”吗？ 没错，我们容易陷于“没有行动”的泥潭，一再抱怨生活的寡淡，情绪的低落，百无聊赖地刷着微博和朋友圈，却不肯抽出哪怕一天中的半小时去运动，不愿抽一天中哪怕十五分钟去书写值得感恩的事。我们用不屑一顾的眼神看着世界，仿佛这才是成熟世界的通行证。 我们怀揣各自的忧怨，觉得生活本该如此，谁不是一样？完美主义经受着自我的折磨，拖延症反复质疑自己，焦虑的人夜不能寐。 Tal教授就是一个典型的完美主义者，大学时代的他表面上拥有了一切，但他不解，为什么不快乐？要如何变得更快乐？于是他开始研究“积极心理学”，不断实验其中的方法，用自身的转变来验证，得出一个较为完整的科学体系，分享给世界各地的人。 毕竟，生命的最终目标是快乐。 健康模型和疾病模型疾病模型：我病了，我的病该如何治疗？我要怎么样才能摆脱病魔？ 应对：你不舒服？哦，那就去治病吧。 健康模型：我病了，是因为我不够健康。因为我没有追求那些让我健康的东西，没有做到我该做的。 应对：你不舒服？那你应该加强锻炼，注意健康。 发现两者的差异了吧！疾病模式注重的是针对病痛来寻找方法，而健康模式注重的是建立一个强大的心理免疫系统。不生病不代表健康，摆脱抑郁并不意味着快乐。摆脱消极和变得积极不是一回事。我们追求的，不是避免痛苦而是更多的快乐。 由此引申出两种不同的研究方式：积极探究和消极研究。 钻牛角尖也同理：我一定要想明白这件事，想通这件事，否则我永远跨不过这道坎！但我们都清楚，就算想明白了这件事，还会有“那件事“，你担心完了这一出，还有下一茬。抑郁等负面情绪，如病毒般存在于我们的体内，它和我们是共生的关系。免疫强，病毒歇菜，免疫弱，病毒肆虐。因此，与其把注意力集中在如何面对病毒，不如换一个角度，增强自身的免疫力。心理免疫系统再强也不代表不再得病。而是意味着我们更有抵抗力，即使得病也能很快的恢复。快乐的人和不快乐的人的区别不在于是否会伤心难过，他们都会，只是快乐的人能更快地从悲伤中解脱和恢复。 积极心理学是一个健康模型，智力上，情感上，心理上，人际关系上，人格上全面发展。 积极探究和消极研究 不论是学术还是媒体，都更倾向于关注消极的部分，看看每天的新闻，几乎都是坏消息，哪里地震了，哪里火灾了，哪种食品又出现安全问题了，再看看学术界，绝大多数的文章都在拼命研究如何对抗抑郁、焦虑，专注于负面情绪。长久下来，我们也跟着它们的思路，不断强调着人类的短处、缺失和过失，导致的后果是越来越多的人抑郁。事实上，这种信息接收的现状是不健康的。 我们应该更多地去关注那些快乐的人为什么会快乐，而不是那些抑郁的人为什么会抑郁。研究优秀快乐的案例比研究普通人或抑郁人群更有意义。从最优秀的个体中吸取经验，应用到普罗大众，时代才会进步。everyonebenefits, when we study the best. 幸福的基础水平 所谓基础水平，就是幸福感的稳定状态，可别和考试得了第一名或吃了一顿大餐的短暂幸福感混为一谈哦！短暂幸福是基础水平上的峰值，之所以称之为“短暂”是因为短期内必会回落。比如，高考之前你觉得考上哈佛就够快乐半辈子了，但事实上你只开心了半年，或三个月，也可能只有一个礼拜。如果你原来的幸福指数是60分，哪怕考进哈佛，6个月后的幸福指数又会回到60，而如果你没有考进哈佛呢？你会郁郁终生？不，半年后也是回到60。再比如，一个悲观的人中了彩票，会永远过上幸福的生活吗？不，狂喜过后，你该怎么抑郁还是怎么抑郁。情绪会因外部事件波动，但基础水平的改变可不容易。 影响基础水平的三个因素：1 遗传排列，2 外部环境 ，3 意向活动。 从出生的那一刻起，基因就已经决定了我们的幸福基础水平——这就是为什么有些人天生嘻嘻哈哈（偏向于快乐），而有些人天生愁云满布（偏向于焦虑）。长大后，基础水平会因为外部因素而提高或降低，比如健康状况，国家制度（生活在民主制度下的人们比独裁制度下的人们更快乐）以及家庭环境等因素。这里不得不强调一点，关于财富对幸福基础水平的影响，研究发现，人的基本需要得到满足后，财富对幸福的影响其实很小。住在别墅里的人一定比无家可归的人感觉幸福，但不一定比住在舒适公寓里的人幸福哦！ 看到这里，你应该已经发现，遗传排列和外部环境很难撼动，但别忘了，还有第三条——意向活动。 那么，如何提高幸福的基础水平？ 改变你关注的东西。 关注 幸福依赖于我们选择关注什么。we seewhat we look for ,and we miss much of the what we are not looking for eventhough it is there. our experience of the world is heavily influenced by wherewe place our attention. 几乎每一条迎面扑来的信息，都有AB两面，选择的“关注点”深深影响着我们。解读比信息更重要。我们不能改变接收的内容，但我们能改变自己的容器形状。 难道要向鲁迅笔下的阿Q学习？自我安慰？ No!不是一味“退一步海阔天空”，而是将注意力逐渐转移到积极的方面，当这种思维方式成为习惯，成为那条主导的河流，哪怕你处于和以前同样的状况，也会迎来完全不同的心情。比如你是一个在医院的清扫工，如果你整日觉得在为了一口饭起早摸黑，一定工作得不快乐，但如果换一个角度，这个医院因为有你而洁净舒适，而且你在工作的过程中又很好地锻炼了身体，是不是完全不一样了？既然你不能改变做清扫工这个现实，就要努力去寻找清扫工的积极方面。 只是不知何时，这种积极思维的“乐观模式”被冠以“盲目”，和浅薄等词混在了一起。似乎悲观地预测，胜算会更大，不至于被人诟病。 但是，我们不能被这股消极的河流冲走，要去欣赏积极的部分，并让这部分增值。 To appreciate what is working, when weappreciate good ,the good grows. appreciate有两个意思，一个是欣赏,另一个是增值。当你欣赏一个品德或方面，它会增值。相反，把好的东西看做理所当然，它会贬值。人的潜力就像种子，给点阳光和雨露才会生长发芽。爱情关系也一样，要让好的方面（潜能，优点，品德和能力）增值。 不论处于什么情况，尽量让自己成为”主动者”。自怜和抱怨只能造成愤怒和沮丧，还是想办法打开另一个世界吧。 神经的可塑性 改变大脑不是梦。神经是有可塑性的，神经通道不断生成，新的神经元不断生成，开始很薄，经过刺激后慢慢变厚，逐渐变成一条河流。想象一下，倾盆大雨时，水落下来流入已有的河流，流向我们建好的渠道。如果之前什么都没有，让雨水流成一条小溪或小河非常困难，我们的经历更倾向于让雨水流向已经建好的渠道并进一步加固它，而不是建造新的渠道。而一条不坚固的小溪，可能马上就会被大雨冲走。 一个建造“担忧渠道”的人，不论发生什么事都会担心，把好事也理解成需要担心的事，或者非常擅长从好事中找缺陷。因为他的渠道已经根深蒂固。比如在聚会上看到一个外向多话的人，有些人认为他啰嗦烦人，有些人却认为他热情友善……这就是流入不同渠道所产生的不同结果。习惯也是如此，一种方式反复巩固，就能改变大脑的通道。所以，建造并加固“积极思维”的通道可以让我们更容易受到积极情绪的感染，对痛苦产生更好的承受力。 要如何建造新的神经通道呢？只有改变！ 改变 改变分为两种，一种是渐进的改变，另一种是剧烈的改变。 学习乐器是渐进的改变，在不断重复中建造大脑新的通路。学习的过程也是享受的过程。 剧烈的改变需要足够的准备功夫。所以两种改变都需要时间。快速改变，立即改变，轻易改变会让人变得更加忧郁更加焦虑。人们都希望找到一步奏效的方法，但是很可惜，没有。 有些人一直说要改变但迟迟没有行动，其中一个重要原因是，他觉得改变了某个缺点之后，会将与缺点相关联的优点也抹去。比如，我想摆脱古板，但是言行一致对我来说又是很重要的品格，那么我就很难去真正改变自己。因为我认为这两者是相互关联的。我不想把婴儿和洗澡水一起倒掉。而事实上，这些品格是可以拆分的，留下婴儿，把水倒掉即可。关键是要弄清楚你想改变的是什么。 有些人说我做出改变了，但没有足够的自律和毅力坚持下去，总是半途而废怎么办？毕竟，游戏比长跑有趣多了。 OK，这就牵涉到“自律”的问题。其实自律是恒量的，不会增多也不会减少，你现在拥有的就是全部。令人欣慰的是，你现在拥有的自律也够用了，因为你可以将自律转化为例行公事。 我们每天起床刷牙洗脸上学上班，在火星人眼里可能是超级自律的表现，但是我们自己心里明白，这不是理所当然的吗？对，要的就是这种理所当然的感觉，当你把运动或者你想要做的改变也转化为“理所当然”，事情就会变得简单多了。 爱情关系也是一样，每周例行两次约会。听起来是不是有点悲哀?这是真情流露吗？在约会中做的事情是真情流露，但次数要规定，否则以后可能会演变为每十年两次约会了。把你觉得重要的事，做成例行公事。给予它充分的注意力和时间，来抵抗其他吸引力的冲突。建立例行公事需要大量的自律，但是保持例行公事只需要少量的自律。切记！不要同时进行好几件需要自律的事，因为自律是有限的。分批进行较好。建立一件一件例行公事，打开一条又一条新的神经通路。 每周一问问自己，做了什么改变？ 感激 “感激”是我们必须用心挖掘的一条最重要的“渠道”，因为人类倾向于对自己已经拥有的事物麻木不仁。而且人类还喜欢攀比，更是将目光对准了自己没到手的东西，于是我们看不到自己的所得，也就感受不到幸福和满足了。 培养感激需要一次又一次的练习，直到变成习惯，变成我们性格的一部分。不要等到悲剧来临才知感恩。 比如每天写五条值得感激的事，尽量不重复，尽量多元化，这样有助于让你看到更多值得感恩的事。你可能会觉得这么做很幼稚，就像小学生写流水账，我心里感激就好啦，干嘛要写出来？ 必须写下来，才能慢慢建造渠道，而且，你会有意识地开始在每天寻找值得感恩的事，用心思考我们拥有的美好事物。不断刺激加固，这么做从本质上创造了一个新的现实，被我们忽视的现实。光靠心里偶尔的感激，只是泥地里的脚印，大雨一来，便被冲得面目全非。 你也可以选择写感谢信，然后登门拜访，读出信的内容，这个有点难为情，但据说效果非常好。这周打电话，下周拜访，再下周写信，让它变成仪式，但变换形式。仪式是唯一的真正持久的改变。 助人为自己乐 帮助他人就是帮助自己，两件事结合成为一个上升螺旋（良性循环）。 快乐不是恒量的，你多我一定少，而是会互相感染的。如果我更快乐，我就更可能感染身边的人，让快乐的总量变大，所以让自己更快乐从个体上看是自私的，从长远来看却不是自私的行为。快乐是道德的！一根蜡烛可以点燃一千根蜡烛，蜡烛不会因此缩短寿命，快乐也一样，不会因为分享而变少。 笑也会传染。假设你感染了三个人，然后这三个人又分别感染了三个人，那么整个世界都会因你的笑而变得不同。 千万不要吝啬于分享，众乐远比独乐来得更有存在感！怕吃亏只会不断失去，越分享拥有越多！ 这也是我写这篇长文的初衷。 环境的力量 我们的大脑不喜欢内部和外部存在差异，所以会不惜一切做出协调——要么改变外部现实，要么改变自我思维。 我们不能改变大环境，但在力所能及的范围内改变自己的生活环境和意念环境不是梦！ 放心，我不是要你整理房间，说什么一屋不扫何以扫天下，而是让你将环境布置的更为“幸福”。 人很容易进入角色。一个人扮演狱警一个扮演囚犯，没几天，狱警就变得凶狠跋扈，而囚犯变得逆来顺受。同样，如果处于年轻的环境，你也会更有活力。所以，让自己进入积极的情境！哪怕在想象的世界。 把你爱的人和爱的事物的照片放在看得见的地方，潜意识会提醒它们的存在。它们也会一遍一遍帮你回忆起当时的愉悦。 这就是高峰体验的震荡效应。 大家都知道，创伤有后遗症，有些人至今还活在911的阴影之中，与此相对地，极其幸福的体验也会有震荡效应，甚至能带来超越体验本身的效果。比如我在2009年的北海道吃过一顿无与伦比的海鲜大餐，我将这种感觉写成了文字，每当读到这部分，那种幸福的感觉会在我的体内再次出现！既然这种美好的回味能带来幸福的感觉，为什么不常常提醒自己呢？为什么不在高峰体验之后创造新的通路呢？专注能让我们感受更多高峰体验。 允许自己为“人” permission to be human. 我们追求到了快乐，并不意味着再也感受不到悲伤。快乐不是对不快乐的否定。快乐和消极的情绪来自于同一个管道，当我们抑制消极情绪同时也抑制了快乐情绪，当我们释放消极情绪的同时也释放了快乐情绪。 人生在世，不如意事十有八九，当事与愿违的事情发生，悲伤，愤怒，失望等负面情绪必然会向我们袭来，这并不代表我们很失败，很没用，而恰恰证明了我们依然活着，我们尚有感受性。当今社会，大家死要面子，互相攀比，掩饰或粉饰自己的生活和境遇，造成了美满的假象。这种假象直接导致的后果就是你开始怀疑自己的糟糕境遇和负面情绪是不正常的，是由于自己的失败导致的，于是，为了不让别人看不起，你也加入并壮大了这个骗局。 然而，拒绝接受现实，生活会处处受挫。不要和人性抗衡，允许自己哭泣，大笑，企图压抑，只会加剧。面对妒忌、愤怒等人性，认可它们的存在，主动接受而不是屈从，用心感受它们，这会是你了解自己身体的重要途径。了解自己，才能更好地了解别人。Learn to study ourselves.越是个人的东西，个人的深层本性，越是对普遍人类本性的认识。 至于如何疏导负面情绪，研究发现，书写描述和向别人倾诉会胜过一直想啊想。有些人说，让我静一静，其实在钻牛角尖。钻牛角尖的最大坏处是它会让意识变得狭窄，紧缩，这种狭窄紧缩模式会造成下行螺旋，即恶性循环，最终可能造成抑郁，而扩建才是良性循环。让眼界变宽，关注其他人，其他事，思考：现在我能做什么？我能去哪里，我要把时间花在哪里？看滑稽电影，和朋友交流，深呼吸，去体会情绪，然后转移。 当我们允许自己感受痛苦的情绪，就更容易体验积极的情绪。这可能就是张爱玲所说的“因为懂得，所以慈悲。” 目标 人无远虑必有近忧。设定目标不仅是为了更好地完成某项任务，还是给我们带来幸福感的重要举措。 何以见得？难道不是吃吃喝喝，毫无负担的生活更开心，更幸福吗？制定目标听起来就压力山大，何必把自己搞那么辛苦？ 实则不然。大多数人期待着退休，但真的退休后又闷闷不乐，原因就在于失去了目标。不论在人生的哪一个阶段，制定自我和谐的目标都可以让我们更快乐。何为“自我和谐”？就是将自己置于风险，离开舒适区（得心应手），来到拉伸区（有点挑战），但不要越过界限走进恐慌区（极其挫败）。最好呆在拉伸区，感受适度的紧张和刺激，摆脱“舒适的麻木”。你在拉伸区时，潜能会被不断激发，感受到持续的成就感。too easy is not necessarily good.peoplewill be more happier when they have choice. 你也可以制定一个看起来不切实际的长期目标，拆分为许多中期目标和短期目标。然后制定计划，基于这些计划建立习惯，一步一步，将成功细化。就会相信那些目标其实是可能的。要想“如何去做”，而不是“是否有可能”。你会看到一个完全不同的世界。而且，人一旦全心投入，会触动冥冥中的天意，来帮助他实现目标。Whatever you can do , or dreamyou can,begin it! Boldness has genius magic and power in it.——Geothe 设定目标才能享受此刻。顺其自然不可行。目标能激励我们，给生活注入活力。实现目标不会给我们带来长久的幸福，但是实现目标的过程却可以。 自我和谐的目标和自我和谐的旅程，共同组成了快乐的所在。 行动 光有目标，“吸引力法则”是不够的，意念的力量很大，且有效，但只有配合行动才有结果。 行为影响态度，增加自信。我们培养习惯，习惯反过来塑造我们。如果态度变了，习惯未变，时间一长，态度还是会被行为拉回原来的状态。所以听课看书时的灵光一现不能说明什么问题，除非你真正去应用，去行动了！ 如何行动？就从今天开始，Never late! 改变很难，但别无他法。可是，我有拖延症怎么办？下面是5种切实有效的方法：· 五分钟起步：要先开始有行动，然后才能有兴奋点 ·把计划公布出来 ·团队工作 ·把目标写下来 · 允许自己去休整 一切都从付出努力开始。行动的结果是更多的希望和乐观的心态。 压力和休息 有了目标我们就要努力，但是那些好胜心杠杠的人看起来似乎一点也不快乐，每天忙得像狗一样！压力太大真的好吗？ 首先我们要判断压力是不是一个贬义词? 当然不是。我们生活在地球上，从未离开过大气的压力，我们锻炼肌肉，也是靠着器械的压力…… Stress is not the problem. The problem is lack of recovery. 压力对我们是有好处的，问题不在于压力，在于你是否得到了充分的休息，是否恢复了精力。 先说说如何提高效率。用一个小时或一个半小时的时间来短跑，专注做一件事，然后用至少15分钟来放松，恢复，可以是冥想也可以听音乐，健身。午餐时间不看手机不看微信，否则会增加焦虑。这种方式能将我们的精力保持在比较高的水平线上，且会变得更快乐。哪怕一天只工作6小时，效果都比10个小时好。效率更高。将时间分割成小块，你也更容易获得成就感。维持生活的灵活性。聚焦工作，聚焦修整。 休息可以分很多形式，其中睡眠是最重要的投资。拒绝多任务模式，那样只会事倍功半。时间充裕的人往往能获得更多幸福感。请闭起眼睛，全神贯注地听你喜欢的音乐。休息也需要专注。利用红灯的时间深呼吸。有时候，休息过程中会突现惊人的创造力，很多好点子都是在洗澡时出现的，当然，这不意味着前面的努力不重要。 运动和冥想 精神和肉体的关系密切。 心理学专家们总是把过多的关注放在脖子以上，而真正发生在我们身上的问题都在脖子以下。 我们的祖先都是在运动的，人需要一定的运动量，但是现在我们没有达到，所以心理上也出现了前所未有的抑郁。我们总是觉得运动是最可以被放弃的，因为太忙，有太多事情等着我们去做。为此我们付出了生理上和心理上的代价。不要和自然对抗，多多运动起来吧！ 运动是灵药。运动要多样性。跳舞，打篮球，骑自行车，花样越多越好。研究表明，每周锻炼三次的效果和抗抑郁的药物是差不多的。而冥想能让我们感染到更多的积极情绪。运动配合冥想，一个对身，一个对心，双管齐下。相信我，如果你将这两件事做成例行公事，自尊，自信，吸引力会接踵而至。 幸福的灵药： 1， 每周4次半小时的身体锻炼； 2， 每周6~7次15分钟的意念锻炼（冥想等）； 3， 每天保持8小时的睡眠； 4， 每天12个拥抱（多多益善）。 最后一个难倒了害羞的我。 自信 我们要的是Groundedself-confidence(有根据的自信)。 我凭什么自信呢？我没有大长腿，没有花容月貌，情商智商皆平凡，你要我怎么自信？ 提高自信的途径之一是改变内在因素，改变看世界的角度，会有不同的理解和感悟，不同的待人处事方式。你没有大长腿但是你有大眼睛啊！我们都是独一无二的存在。关注自身优秀的方面和潜能,去栽培它们,而不是一味想自己有什么不好,而陷入恶性循环。一个看不到自己优点，只关注自己缺点的人是不会有很高的自尊心和自信心的，也鲜有快乐的源泉。 提高自信的另一个途径是去冒险，去尝试。做让你感到兴奋的事。想象一下你在一个没有人知道的世界中，你会怎么样？什么东西对你来说是重要的即使没有掌声也会去做？什么情况下你忘我工作？有信念并面对现实，有勇气和敢于尝试，一次次证明实际的失败痛苦比想象的小很多，自己能应付，于是你会变得越来越自信。只要做了，就比不做离成功更进一步。如果害怕失败而迟迟没有行动，等待你的只有越来越不信心，越来越懊丧。 追加——VIA 认真做了24种人格力量测试（VIA）。我的10种人格力量是：爱（49分），爱学习（48分），好奇心（46分），欣赏美丽和卓越（敬畏，赞叹，上进）（44分），宽恕和仁慈（43分），幽默（爱玩）（42分），创造力（42分），感恩（42分），善良（41分），有活力（热情积极，有魄力，有精力）（39分）。 测试中所展现出的就是你的特质。应用你的特质，让其成为习惯，再来慢慢成就你的生活。 自尊 自尊是对能力、身份、成就、价值的自我评判。 自尊分为三种：依赖性自尊，独立性自尊和无条件自尊。 依赖性自尊：由他人决定；能力感来自于与其他人的比较。需要外界的认同和赞美来获得自尊，这种自尊的提升是暂时的，一旦赞美变少，马上陷入自卑的漩涡，否定自己。这种自尊极不稳定，趋于敌对。 独立性自尊：由自己决定；跟之前的自己作比较。即使没有赞美也知道自己很棒。这种自尊更为稳定，趋于仁慈。 无条件自尊：有充分的自信；interdependence.从别人的幸福中一样获得愉悦感。它不意味着冷漠，或者回避他人情感，事实上我们更加关心他人了，更有同情心了. 我们让自己远离羡慕嫉妒，高傲和自卑，远离攀比。我们和他人融为一体，如同看电影般看着他们，自我不受威胁。我们或多或少都有依赖性自尊，关键是程度。不能让依赖性自尊成为主导。我们也很难做到无条件自尊，因为太高大上。所以我们的目标是——独立性自尊。 Why? Because no one is coming，是的，没有人，你独自来到这个世界，也将独自离开，你必须对自己负责.为了幸福你必须提高自尊，因为高自尊隐含了一个概念：我值得拥有幸福。 提高自尊的方法：1.正直：言行一致 2.自我察觉，自我了解 3.承担责任，只有靠你创造生活 4.自我接纳 5.要有主见 简单说来，提高自尊就是让自己看得起自己。能力感+价值感组成了意识的免疫系统，让你更能够感受到积极的力量。 Self concept is destiny. “自我概念即命运。” 两性 当我和你变成了“我们”，就一定会有牺牲。 要努力经营，同时接受人总是追求新鲜事物这个事实。伴侣之间既是同盟关系，又有竞争关系，如果步履不一致，拖后腿的那个难免被弃。你不努力生活，一心追求安逸，以为婚后万事大吉，对方永远爱我？别做梦了，前面说过了，No one is coming.只有付出努力，你才配得到爱。自我修炼的路，只要活着，就没有终点。 Tal教授一再强调，在一段关系中，被了解比被认可更重要。因为他觉得展现真实的自我才可能进行深层次的沟通，不至于为了得到认可而伪装自己，可以活得轻松一点。但夫妻在一起久了，即便互相了解，如果无法认可，应该也走不下去吧？所以我认为，被了解和被认可同等重要。我希望你了解我的性格和喜好，也希望你认可我为你做的改变。 吵架有利于增加感情的免疫，这也是另一种形式的沟通，但记得，你不会对泛泛之交做的事也千万不要对你亲密的人做，不要以为你有这个特权，一旦伤了对方的心，可能永远弥补不过来。多看看对方的优点并发自内心地赞扬ta,认真记录ta让你感动的每一个瞬间，每一件小事，多说说这些温馨的话题，多感激对方的付出，多聊聊浪漫的秘密，当两人同时泛起甜蜜的微笑，就是千金难买的幸福。Love is in the details. 我们越独立 我们越相互依赖，这个成长的过程就像是学走路，跌倒就爬起来，只要你依然伸手迎接。 总结——关于乐观主义的两个问题 问题一，既然乐观主义者那么幸福，为什么不是每个人都是乐观主义者呢？ 媒体让我们觉得乐观主义不切实际。在这样一个世界，怎么乐观？怎么积极？快乐和幸福如何谈起？“习以为常”让我们对好事麻木，寻求反常态。从某种程度上说，人性中的“适应性”是好事，但也造成了麻木。我们的潜意识里认为幸福和偷懒互相关联，因为 no pain no gain，所以我们都选择了不快乐，以为牺牲快乐才能获得其他珍贵的东西。 问题二，如何成为一个乐观主义者？ 学会感激，你总能找到值得感激的事儿。专注的事情会变大，专注于好事，你就会创造出更多的好事，所有机会滚滚而来，你也会因此变得越来越快乐。 花了差不多一周时间，将23堂幸福课浓缩成1万字，其中有不少是我的补充和感想。 幸福是终生的追求，永远保持自信和好奇心吧，少男少女们！编辑于 2015-10-29 152 条评论 感谢收藏 • 没有帮助 • 举报 • 作者保留权利yang yang 现在是全职的家庭主妇。148 人赞同The Science of Happiness - 幸福的科学 - 我学的不是哈佛的课程，是Berkeley 大学的另一门课程。学习积极心理学真的改变了我的生活。让我脱离了忧郁症的泥潭 这是我写在课堂笔记中的感想： 学习积极心理学，重新开始幸福人生 2011年，我经历人生的低潮，在工作和生活的双重压力下，我患上忧郁症。在老公的苦苦劝说下，辞职做了全职太太。在以后很长一段时间，依靠药物艰难度日。 听说积极心理学是在2012年，看了泰勒·本-沙哈尔的书《幸福的方法》，我开始努力的调整自己的心态，寻找生活的意义。但作为家庭主妇，我很难在找到在职场中那种成就感。“Flirting with disaster every day (每天和灾难调情 - 老板对我们工作性质的评价)” 我不断的问自己什么是幸福？ 以前自己写过以下两段的文字： “移民前，曾经想象过自己在加拿大的幸福生活：一杯香浓的巧克力，一张软软的摇椅，在暖暖的壁炉前，听着轻音乐看一本有趣的书，偶尔抬头欣赏窗外的飞雪。 如今，我拥有这一切，可我失去了欣赏它的心情。” “小时候的幸福就上考上重点学校，上重点大学。上了重点大学后，幸福就是找个好工作。 工作了，幸福就是嫁一个能干的老公，然后是出国。移民了，幸福就是能上学读书，能找到一份好工作。然后，幸福变成了有一个孩子，变成了买一个独立的别墅和读完我的行业证书。 今年12月13日，我在我幸福目标上的所有项目都完成了。12月8日考完了最后一门课。老师说我成绩不错。 12月13日买下了一个独立的别墅。 2月份，我，老公和儿子就又有一个完全属于自己的家了。 谁能告诉我现在什么是幸福？ 下一个目标是什么？” 通过这门课程的学习，在这10周的时间里，这个课程提供了很完美的答案，和很多实用的解决方案。 “Happiness：the experience of joy, contentment, or positive well-being, combined with a sense that one’s life is good, meaningful, and worthwhile.”（幸福是一种快乐，满足，或积极的体验，是一种能够体会到生活是美好的，有意义的，而且有价值的感觉。”） 以下是几个我认为对我最有帮助的作业和观点： 第一周的作业：写下三件让你开心的事情。这是一个非常简单的作业，但它让我的注意力转移到了一些开心的事情上，每天睡觉的时候都有一个愉悦的心情。所以，当我在写第四天的作业的时候，我注意到自己的睡眠好一些了。主要感觉是：入睡比较快，睡得比较沉。对于一个曾经的每天只能睡三个小时的忧郁症患者，现在依然饱受失眠困扰的人来说，这是一个巨大的改善。 第四周：宽恕。这一周的内容对我的改变至关重要。少年痛苦的人生经历对我的人生影响巨大。我不知道我的人生中，居然可以有这个选项。我不知道我是否可以做到，但知道有这个选项后，我的生活开始有了一个全新的视角。对于我而言：可以说是选择宽恕，放自己一条生路。 第五周的作业：专注呼吸（类似冥想）。要求很简单：一周时间，每天15分钟，练习如何专注的呼吸。只是注意自己的呼吸，不要想其它的事情。学习了这周的课程，我才知道，走神居然有如此巨大的危害。走神时，人很多时候是在回忆过去（revisit your past），计划将来（plan your future）。回忆过去，我常常总结自己为什么当时没有做好，于是在内心里责怪自己，人变得更加忧郁。计划将来，我常常在心里梳理每一个细节，计划着最完美的结果。但事情不总是按我的想法来，如果没有出差错，我认为是理所当然，从来不会表扬自己；一旦事情出差错，我会很生气（为什么当初我没有考虑到这个细节？），于是更加焦虑。 学习了这周的课程，我才知道，为什么心理医生要求患有忧郁症的病人：stop thinking, start to live（停止思考，开始生活）。只有专注于现在，人才能容易获得幸福感。在以往的冥想练习中，我觉得非常累。我注重延长呼吸，屏气（hold your breath），这样搞得自己非常累。我不容许自己走神，但我很快发现自己又走神了，于是狠狠地责备自己。这样的冥想不是在放松，不是在培养专注力，而是一种辛苦的工作，在培养自己的愤怒、紧张和烦躁。在这门课程中，按老师的要求自由、正常、轻松的呼吸，不要延长呼吸，不要屏住呼吸，只是知道自己需要专注呼吸就好了。发现自己走神时，只需要提醒自己：嘿！亲爱的你走神了，快回来吧。然后，重新开始就可以了。不要批评，自己鼓励自己多多练习：“what you practice gets stronger.”（熟能生巧）。很多次我躺在床上练习，练着练着，自己就睡着了。现在自己在散步时，也能做这个练习了，专注能力提示了很多。 第七周：自我怜悯。要强的人对自己要求都很严格。我们经常非常严厉的对待自己。我知道很多人因为对自己不满意，曾经狠狠的伤害过自己。学习这周的课程，我知道了只有全面的接受自己，才能改变自己。“忧郁症不是一个人的弱点，它只是告诉你：你选择坚强的时间太长了。（Depression Is Not a Sign of Weakness. It Is a Sign That You Have Been Trying to Be Strong for Too Long）”。每天睡觉前，给自己一个拥抱。让自己有一个柔软的心情，进入梦乡。 第八周：感恩。学会感恩，表达你的感恩。不仅能提升自己的幸福感，而且能让周围的人都能感觉到幸福，这样可以增大你的社交范围，和周围的人有更多的联系，这是感觉到幸福的重要方法之一。在儿子的学校里，印度人开始了一个传统：过生日的小朋友会给全班的小朋友一个礼物袋（loot bag）。几个星期前，一位华人妈妈的小儿子也送给了我儿子一个。儿子很喜欢其中一个套在手指头上的手电筒，说是：可以发射激光的枪。第三天，在等儿子放学的时候，我看见这位妈妈远远的站在我后面。我走过去对她表示感谢，谢谢他儿子的礼物。然后，我们开始聊天。以后，只要有机会我们都会说说话。一天，她的大儿子放学了，她还没来。我就告诉她大儿子：妈妈还没有来，你需要再耐心等一会。他大儿子问我：你和我妈妈从小就是好朋友吗？我说：不是。你弟弟和我的儿子在一个班上，我们是这么认识的。他说：你是第一个我妈妈在这里认识的朋友。从这件事情上我得到了很多的鼓励。我积极的和周围的妈妈交流，提供力所能及的帮助：帮不懂英文的妈妈翻译学校的文件，帮有事来不及送孩子的妈妈送孩子上学，给大家介绍好看的电视连续剧。几个星期下来效果显著。本来周围的妈妈有自己的圈子，讲广东话的妈妈、讲普通话的妈妈和讲福建话的妈妈之间从不交流，但现在大家常常站在一起用普通话聊聊天，分享以下自己种的花、种的菜、做的可口饭菜、育儿经验、抱怨老公、娱乐新闻等。大家每天笑笑，心情愉悦很多。 今年12月1日，这门课程会从新提供给大家。而且这次，这一门变成了自适应的课程。你可以根据自己的时间来觉得学习的速度，只要你在2015年5月31日前完成就可以了。（You can also register now for a completely self-paced version of the course, which offers a new opportunity for a certificate and discussions with classmates. The self-paced course will go live on December 1, with all course material available at once. You’ll just need to complete the graded assignments by May 31, 2015, to earn a certificate of completion.）但这门课程阅读量很大，对于英语不是母语的人而言，每周4-5个小时的时间，远远不够。上课时，同学给老师提了建议：让他们多给点时间给大家。结果老师还真的把考试结束的时间从11月16日，给推迟到了11月25日。否则，我肯定完不成。刚开始时，我同时在学三门课。学到一半，放弃了另外两门课程，专心学这一门，这样拼命的赶，才学完。没有拿到优秀，总分只考了79分。（将来我会再学一次，争取拿到优秀。） 在西方有“happy wife, happy life”的说法。老公们常常用它来劝解自己满足太太们的要求。可是，成为一个幸福的妻子，拥有一个幸福的家庭，光靠老公满足妻子的要求是不够的。作为妻 子，尤其是全职太太，将自己变成一个幸福的人对于家庭至关重要。因为，你是整个家庭的中心。你可能没有想到，当你深情款款的对老公辛苦的工作表示感谢，对他会有多么的重要。当我这么做的时候，我看到了老公眼里闪动的泪花。一个幸福的人在面对困难的时候，更多的选择是坚持。当儿子气得自己七窍生烟时，这种坚 持表现为控制情绪，理性的面对，和他讲道理，而不是大发脾气，惩罚他。 获得幸福的方法有很多种，希望大家在学习这门课程以后。能够找到一种或几种适合自己的方法，让自己更加幸福，远离忧郁症。 我推荐大家都来学学，尤其是患了或者患过忧郁症的朋友。这门课程不仅给我打开了一扇门，它犹如一缕阳光照进了我的世界让我感受到生活的幸福。我相信它也能让你用一种不同的心态去看待生活，让你在平凡的世界里获得更多的幸福。 http://mooc.guokr.com/note/13811/发布于 2016-04-18 57 条评论 感谢收藏 • 没有帮助 • 举报 • 禁止转载匿名用户30 人赞同 课程的内容好坏且不说，我校把幸福公正这种老少咸宜的课放上来给大家看就是非常机智的。这种课的意义就应当是让很多人获得生活上的改善，而不是看完了给发个学位。 反例就是耶鲁发的文学理论导论，我当年看了一遍没完全明白，现在总算明白了，也不需要去网上看公开课了。 当然如果认为哈佛就是幸福课公正课，这种课就是所谓的人文教育素质教育的话，那就醒醒吧。发布于 2015-03-16 5 条评论 感谢收藏 • 没有帮助 • 举报 • 作者保留权利叶苏 白洞，白色的明天在等着我们。喵！74 人赞同去年把这个课程听完了，今年又听了一次，记了笔记，基本就是每节课的主要内容（在我看来的），分享给大家。 这门课节奏很慢，很多内容不停地在被重复，甚至不少内容让人感觉过于浅显泛滥，所以被不少人看轻，但其实这门课程是非常好的。tal教授在课程中也解释过，幸福课教授的内容并不是新的，而是提醒你已知的知识。Common sense is not that common. 另外，教授知识是一方面，转变思维方式也是一方面。“为什么听过很多道理，依旧过不好这一生”。听过道理，并不代表你理解；理解，并不代表事情发生时，会按照正确的思维方式去思考（错误惯性的存在）；最后，哪怕你正确思考了，不真正赋予行动，也没有实际意义。最后，付诸行动了，同时还需要引入情绪及认知上的改变，固化我们区别于以往思维方式所做的改变。 幸福是值得努力追求的目标，这么课程从整体思维方式的转变——注重起作用的，而不是仅仅注重需要需要改变的地方，讲到影响我们幸福感的具体方面如培养良好的爱情、睡眠、锻炼的习惯，以及如何改变拖延，不是依赖意志力，而是通过把想做的事情变成ritual，让良好习惯变成我们生活中的一部分。非常有帮助。 第一课——什么是积极心理学 active note vs. passive note 仅仅把所写的东西记下来，还是投入其中（engage） 与身边的人分享所学，最重要的是在生活中运用所学 自助运动存在的问题为缺少严谨的学术基础，over-promise and less-delivered；学术研究存在的问题为不够通俗（not accessible ）幸福课或者说积极心理学的目的为bring a bridge between ivory tower and academic study; 关于幸福课：1、幸福课要传授的是transformation，而不是information： the class is not just about information, it is also explicitly about transformation——把我们的大脑看做容器，如果是把信息接收当做主要目的，当信息把容易装满，任务就完成了，但还远远不够，我们需要改变容器的模样； 对信息的解读在transformation中非常重要（同样的事情，是失败还是机会？）快乐是头脑的一种状态，而不是实际生活的状态，更不是银行账户的状态。 这门课不是教你新东西，而且提醒你你已经知道的东西。Common sense is not that common. 2、重要的是问对问题，而不是问题的答案。3、幸福课提供的是rigorous fun。fun是因为向内探寻总是有意义及乐趣的（虽然有时也会hurt），rigor是因为坚实的research基础。4、同英语课与历史课等需要付出的努力不同，幸福课最多需要付出的是所学运用于实际生活的努力；改变并不容易——除非我们在引入行为上的改变的同时，引入认知上和情绪上的改变； 关于time-in 和 time-out：1）我们现在的时间大多花在time-out，花在look into yourself 的 time-in 太少。2）time-in和沉默(silence）有很大关系，沉默/安静对于我们的生活、工作、修身等等方面非常重要；3）《the courage to teach》中说道：“语言信息的交流并不是教与学的全部，we eductate with silence as well。Silence gives changes to reflect what we said and heard. Silence is a media of learing deepest thoght。”沉默时间是学习的必要环节。 心理学三大学派；1）行为主义：只研究所观察到的并能客观地加以测量的刺激和反应。如巴甫洛夫的条件反射2）精神分析：代表佛洛依德，研究潜意识（主要负面的）。主要讨论病态人的无意识，所述内容主要有人的梦、过失、焦虑、动机冲突、情绪紧张以及人格的病理表现。其创始人弗洛伊德是一名精神病科医生，主要从临床经验探究病人致病的原因，从而深入到病人的无意识心理的动机、情绪和人格等问题。3）人本主义（衍生出积极心理学）：主要研究正面的。人本主义心理学兴起于20世纪五、六十年代的美国。由马斯洛创立，以罗杰斯为代表，被称为除行为学派和精神分析以外，心理学上的「第三势力」。人本主义和其它学派最大的不同是特别强调人的正面本质和价值，而并非集中研究人的问题行为，并强调人的成长和发展，称为自我实现。 哈佛大学MBA毕业的学生二十年后最成功、最幸福的人的共性有2点：1）really believe themselves.2）always asking questions. They are life learners. 第二课——为什么要学习积极心理学 美国全国范围调查，45%学生曾经历抑郁无法解决。心理学研究32年，发现研究情绪的论文，其中生气5000+，焦虑41000+，沮丧54000+，但是快乐415，幸福2000-，满足2500-。消极和积极的比率是21:1. 为什么在抑郁普遍流行的情况下要研究积极心理学？ 1、研究起作用的至关重要，what we focus on creates reality;如何关注起作用的东西——通过提出的问题本身。案例：大量研究已退学的问题儿童，但是研究带来的变化微乎其微——直到改变研究重点，研究为什么有的人在恶劣的环境下可以成功，而不是研究为什么有些人会失败——得到真相：psychological resilience（积极适应的模式，即便的面对非常不利或危险的环境） People with psychological resilience have these common characters: optimistic—不是盲目的乐观，而是，这次虽然失败了，但我能从中学到什么？ help others—we enter an upward spiral between self-help and other-help, when we help others we are helping ourselves, when we help ourselves we help others. And so on and so on. focus on your strength-- it doesn&apos;t mean to ignore your weakness, but to ask, what am i good at?to identify your strength. set a goal— future-oriented set a role model-- someone you want to emulate, to be like. They gave you strength, sense of direction social support — it&apos;s not that I&apos;m tough enough to do it by myself, rather that I&apos;m tough enough to reach out for help. the courage to admit weakness, to need. 2、快乐并不是对痛苦的否定；克服抑郁也并不代表你自然而然会快乐。就好比一个人消化不良，没办法享受美食，但消化不良治好了也未必代表他就是享受美食的。 疾病模型VS健康模型积极心理学本质上就是健康模型，我们如何让自己从智力上、情感上、心理上、人际关系上、人格上全面发展，而不是仅仅摆脱生活中不如意。（不仅仅是治病，并且要提高身体抵抗力，我们生病，是因为不够健康，让疾病乘虚而入，因此要注重健康，提高抵抗力）——注重培养能力，而非改成错误而疾病模型，goes directly to deal the illness. 3、预防的重要性——专注于培养积极心态；培养积极性实际是帮我建立防御体质。多年研究显示，对抗抑郁的最好方法不是研究抑郁本身（当然这也很重要），而是培养积极性、培养个人长处（personal strength）、cultivate and indentify one’s passion。 对我来说什么是最重要的？我的目的是什么？我想做什么？认真思考这些问题。 Questions create reality：图上有几个几何体？ 我们集中于数几何体，忽略了闹钟时间，色块颜色。 Certain question is asked, which directs you to a certain part of reality. Questions create a very specific reality. During a relationship, &quot;what is not working&quot;, &quot;what&apos;s wrong&quot;, &quot;what do i need to improve&quot; , if they are the only questions that are asked, then that is the only thing we will see——deficiencies, things that are not working.在他们看来，这段关系中就没有好的事情了。就如同，在我们眼中，没有闹钟，没有色块，没有公汽上的小孩。 关于个人，大多数人问自己最多的是，我的缺点是什么？如何改善？而非我擅长什么。如果我们唯一问自己的问题是前者，那么我们看到的只有自己的缺点和不足，而我们的长处，我们身上的美好事物，好像不复存在。而这样的人，无法有很高水平的自信心和快乐。 Setting a role model is important:Marva Collins是怎么做到的 Marva collins 自己就是role model 带领孩子们学习role models，from fiction/ history books，从身边identify role model 真心相信孩子的潜力，同时对他们要求严格，对他们有很高的期待。培养他们的grouded自信而非盲目的自信，也不是不惜一切让孩子们感觉良好。她有很高的期待，欣赏每人的潜力。 停止抱怨，对自己的生活负起责任。 她有乐观精神，帮助孩子设立目标 从关注缺点到关注优点。当优点被欣赏时，优点及有优点的本人都会升值。潜力也是如此，我们不关注它，它自然会消失。 被动受害者VS主动者被动受害者只会自怜，自责，责怪他人。而主动者会行动，会承担责任。 第三课——幸福是随机现象吗 本课首先再次回顾了学习心理学的三个重要原因（整理在了第二课的笔记中） 我们是关注缺点还是优点（很多人认为关注缺点更重要，实际应该更关注优点、长处，至少与关注缺点一样多）；我们更关注克服缺点，还是培养，强化长处？我们擅长做什么，是否取得了进步？ 幸福水平是可以改变的。 虽然研究表明幸福水平与基因成都有很大关系。但如果你是个unhappy person，而且你认为是不可改变的，就会变成一个自我实现过程。你会越来越不开心。 注重可行的方法；study what is working study the best 当我们关注能改变的程度时，关注平均水平是没有意义的。应该关注top tip，关注能改变的最多程度，怎么做到的，然后去应用它(如同研究人能跑多快不会看平均水平，而是最快的人可以跑多快)。Studying the best and apply it to the rest of us. 这并不是精英主义，而是从最好的中学习，运用于大众。“流行学术其实是将杰出大众化” 学习our personal best，学习自己曾经的peak moment and experiences。 第四课——积极的环境能改变人 One of the most significant barriers to people doing things in the world, to actually introducing change, is that they underestimate their ability to bring about change. We underestimate our capacity to affect change because we underestimate the growth of exponential function. （the exponential of human network——if you make 3 people a day feel good and they each make 3 others feel good, and so on and so on, and eventually the world will be made to feel better） 极端情况对幸福感的影响没有想象中的大，在短期内会有大的波动，但很快人的幸福感就会回到基准水平。获得终身职位的喜悦，没获得终身职位的失落都会很快平静,瘫痪，甚至中彩票对幸福感的影响都没有想象中大。财富对幸福感的影响不那么大，当然是在基本需求被满足的前提下。同样，外部环境的影响甚微，如居住地。（民主和自由的影响除外） 长远看来，降低期望并不会使我们更开心，所以不是高/低期望的问题，而是正确的期望V.S.错误的期望。 It is wrong exception to expect that getting into a certain place, getting a raise, finding our dream partner is responsible for our happiness. It will not make us happier. The right exception is to believe in change from within. In fact, our readiness and potential to experience happiness is mostly depended on our state of mind. It’s about changing our perception—state of mind, it’s about changing our interpretation of the world, of what’s happening to us, of our achievements, of our failures. It’s about what we choose to perceive, what we choose to focus on. permission to be human: When we suppress a natural phenomenon, that phenomenon only strengthens. (eg.Do not think of the pink elephant). Before a lecture, you tell yourself, don&apos;t get nervous, and then pink elephants are all around. Painful emotions are as much as part of human nature as the law of gravity is part of physical nature. nothing bad about experiencing anger、envy or anxiety, but how to act as a result of it? We are doing much more, focusing on the positive, and at the same time, accepting the painful emotions. After taking the course, it&apos;s not that you will not have painful emotions anymore, it&apos;s simply your psychological immune system will become stronger. (Remember to give others the permission to be human too) the difference between the extremely happy people and extremely unhappy people is not that one gets sad and the other does not, both groups do. It’s how quickly, how promptly we can remove from these painful emotions. In other words, how strong our psychological immune system is.他们恢复得快多原因的因为interpretation的不同。 Official mantra of Actively Accepting movement : God, grant me the serenity to accept the things I cannot change; the courage to change the things i can change; and the wisdom to know the difference. 第五课——环境的力量 “Happiness is the meaning and purpose of life, the whole aim and end of human existence.”——亚里士多德 消极的循环downward spiral：Narrow &amp; Constrain —-sad—- N&amp;C—sad….on and on till depression积极的循环upward spiral: Broad &amp; Build—positive emotion—-B&amp;B—-PE…on and on till stronger psychology system. 积极的情绪让人更有创造力：In the depressed phase, our thinking is narrow, we don’t think outside the box usually. (医生分组解决难题，先给他们糖果，营造积极轻松气氛的那组表现最好。) 快乐是否自私: Isn’t it selfish to pursue happiness? And the answer is, yes, it is selfish. And equating to selfishness and immorality is the No. 1 cause—subconsciously mostly, of unhappiness. Then how do we respond to it?Happiness is a positive sum game. It’s not that my happiness takes away from other people’s happiness, which is a zero sum game—if I have more, you necessarily have less. Happiness is a positive sum game because happiness is contagious. If I’m happy, I’m more likely to contribute to other people’ happiness and wellbeing.“I know of no more selfish act than a benevolent act.” Helping others is helping ourselves and helping ourselves in turn help others. The fact that our happiness is tied to others, that we are tied to others in a web of empathy, that’s a wonderful thing about human nature. If we don’t appreciate that part of our nature, it will depreciate. Why is feeling good so important ? it feels good to feel good;（积极的情绪让人更有创造力，建立更好的人际关系，etc.） it also contributes others to feel good; “Be the change you want to see in the world.”People mostly do what you do, rather than what you say.（tal叫同学们把手弯成圆圈，放在脸颊上，但他放在下巴上，同学们都照样放在下巴上）. The optimal way to spread happiness is to work on your own happiness, because then you are leading by example.If you want to spread to happiness, you must go for your own happiness first; Beliefs as self-fulfilling prophecies 信念即自我实现预言 2005年，福布斯杂志评选150年来最伟大的20位运动员，罗杰•班尼斯特名列榜首。在体育史上，有一个经典的”1英里4分钟”的故事：自古希腊设立”一英里”赛跑项目以来，没有人在4分钟内跑完，甚至让狮子追赶奔跑者也没能突破。于是所有运动专家用各种理论证明出：1英里4分钟是人类的极限。近2000年来，人们一直相信这个极限。但是，20世纪中期，牛津大学医学院的学生罗杰•班尼斯特不相信这个极限。他是个跑步爱好者，1英里的最好成绩是4分10秒，已经非常好了。他刻苦训练，把成绩提高到4分2秒，然后发现成绩似乎无法再提高了。但他仍旧采用科学的方法刻苦训练，在1954年5月6日，他跑出了3分59秒4的成绩，突破了四分钟。六周之后，美国有另一个人跑出了3分57秒。第二年，跑进4分钟的共有37人，再过一年突破的人数超过300人。这说明最大的障碍在于人的脑子里。 Appreciate the potential, and the potential is appreciated.一个人的IQ被认为是与生俱来不可改变的。一个实验，给一群随机抽取的学生标上”高智商”的标签，让不知情的优秀老师教一年。结果一年后这些学生的表现比其他随机的学生要好得多，甚至于IQ测验竟然得分高出不少。仅仅是因为教师认为他们是”高智商”的学生这个信念下的，这些学生就有了不小的进步。(老师们被提醒着去关注学生身上一直存在的潜力，而这些潜力之前没被注意，像公汽上的孩子没被注意一样，it’s not inventing something or detached from reality)另一个实验。当一个普通的老师被学生理解为是优秀的老师的时候，学生的进步也很明显。 We create our own reality—— “Treat a man as he is and he will remain as he is. Treat a man as he can and should be and he shall become he can and should be.” by 歌德。 The situation is powerful.1）举例：扮演监狱长和犯人的试验。结果一周后不得不中止，因为进入角色太快。2）试验：1979年，若干75岁的老人回到1959年的环境，一周后测试发现这些老人各种指标都明显年轻化了。3）试验：穿上飞行员服装，测试视力提升推荐《mindfulness》作者: Ellen J. Langer 影射的力量：听喜欢的音乐，集中精神听，而不是当作背景音乐；看能激励你的电影；把你喜欢的艺术作品放在身边，这些东西能帮你创造积极的环境，有助于成长，获得成功与产生幸福感。其中大部分都是在潜意识层面上进行的，这就是影射的力量（priming），也是积极研究的意义。通过研究积极环境，我们也是在对自己影射积极的东西 自助运动：理论基础——我们通过思考创建了世界。畅销书如，思考致富、 秘密。它们的中心思想均为，“Whatever your mind can conceive and believe, it can achieve”。人们为这些理论所吸引，因为它们鼓舞人心。但存在的问题是，当今的自助领域强调某个真相，将真相过分鼓吹。我们的精神确实能创造现实，但这只是部分真相。还存在外界及内在的影响，同时也离不开勤奋和坚持不懈。These self-help books are overpromise and under-deliver, which at times can be destructive. 因为它抹杀了勤奋工作、坚持不懈和挫折的重要性，它们也是成功、幸福、圆满人生的重要组成部分。 power of the mind：curry做过的研究表明，56% percent of your successes as an athlete is determined by levels of hope, by how much you believe that you are going to succeed.（由期望度决定的） 信念即自我实现预言的机制如何实现的(how our beliefs, our exceptions impact our performance) motivation when you believe you can do well in something, you are more likely to be motivated. consistence/congruence 当人们内在的信念/schema与外界情况不匹配、不平衡时，人们会感到不安和痛苦，因此人们将有以下选择：1、Update internal Schema 比如改变对一个人的看法2、 Ignore/discard externals 比如远离或视而不见3、Actively seek confirmation 来支持我们对一个人的看法4、Create new reality 改变和创造Research by Dean Simonton shows that the most successful scientists and artists through our history were also the ones who failed the most times. 乐观主义者跟悲观主义者最大的区别在于how we interpret events. 比如，如何理解失败，是大结局，惨败，放弃，还是通向成功的机会。把理解一件事分成永久的以及暂时的。我没找到一份工作，是指我永远找不到工作，还是只是个暂时的挫折，来看看我学到了什么。像乐观主义者这样去理解事情可以获得更高层次的成功，并且这种能力是可以被学习的。推荐书目 适应力因素 karen reivich 成功人士的三个特征——乐观、热情、勤奋。运气也有很大的因素，但拥有这三个特征的人运气往往更好。 错误看法：高期望导致失望—— 生活中的悲欢离合让我们在幸福的基础水平上上下起伏，但总会回归到基础水平（good side: I can take more risks, I’ll recover anyway. Bad side : so am I stuck? so I was born with that base level according to my genes?）——base level 是可以提高的，立竿见影的一个方法：To cope as opposed to avoid. People who cope overtime have the same, or even more ups and downs, but the base level increases.为什么直面risks基准幸福水平线会上升？ Self-perception theory: We derive conclusions about ourselves as we derive conclusions about others.我们通过观察他人的行为给他人下结论，同时我们也通过观察自己的行为给自己下结论。 我们看到有人上台，认为他是勇敢的with high self-esteem，如果自己上台，对自己也是同样看法。 真正来自失败的痛苦，远远小于我们想象的。 When we fail after coping we realize that the actual pain that comes with failures is far less than the pain we imagine and that we associate with failure.——而这会带来自尊水平的上升，因为我们可以应对失败的痛苦I&apos;m actually much more resilient than I thought I was. And my self-esteem increases. There are more successes.There is no other way to succeed. Learn to fail and fail to learn. 第七课——逆境还是机遇 乐观是指诠释的方式，而不是盲目地自我感觉良好的方式。诠释：发生的事情都是有意义的，也许我犯了这个错误，但我已经从中反省并学到东西，这个错误是有原因的。 这件事情发生不一定是好的，但要学习如何在事情发生后最好地解决以及学到东西。 我们如何变得乐观：1、to take action积极的语言，无论鼓励自己还是他人的鼓励在长期看来并不有效，至少对Tal教授本人证明无效。rather than talk, we need action相比积极的语言，我们更需要积极的行动。努力和面对必然能获得成功，至少比之前不行动不面对成功。所以哪怕一点点成功，也有助于提高我们自信。And then, self-confidence in turn motivates us to work harder. 行动起来是让你变得更加乐观的有效方式之一。2、power of imagination：Visualization：当你看着你的手，部分神经元会被激活，想象你看着你的手，同样的神经元会被激活。我们的大脑并不知道想象的事物和真正的事物之间的区别，这也我们的梦为什么栩栩如生的原因。由于我们的大脑不知道想象的事物和真正的事物之间的区别，并且大脑不能忍受认知和实际的差异，我们可以通过想象成功并且坚持不懈，来让大脑让外部现实和内心的想象相符。但还有个关键点，不能仅仅只关注结果。把学生分成两组，两组都一遍遍想象自己在考试中获得了A，但另外一组还想象了自己在图书馆坚持努力，为考试做准备。第二组不仅想象了结果，还想象了过程，他们获得了更好的成绩。So one should visualize the journey as well as the destination.当我们想象成功时，尽可能逼真些，尽量让人感受真实。因为感受越真实，我们的大脑就越相信这是真实的。（这也是著名演讲的特征，它们不是抽象的。演讲很精彩，因为他们involve sense，创造了成功的画面）you have to evoke emotions to create motion3、cognitive therapy基本前提：thoughts drive emotions.思想驱动情感。event发生——evaluation评估（thoughts）——激起emotion——作出相应action 需要避免的三个陷阱：3MMagnify归纳法是人类本能，如小孩子识别凳子，但我们有时候会过度归纳。如将期终考试没考好归纳为我不聪明，我永远不会成功；或者，他拒绝了我，所以所有人都会拒绝我。把失败小题大做。Minimizing隧道视野：将视野过度集中在一个窄小的范围。比如讲师上课，620个学生中，2个在睡觉，便认为自己是个无聊的导师。Making up过度个人化：如，受虐的妻子，我老公虐待我，一定是我哪里做的不够好。或者过度责怪：我考试没考好，责怪女朋友，而不是承担责任。以及情感推理：我感觉到嫉妒，我一定是个很糟糕的人。 总而言之，要get real，要being rational，理性看待问题，纠正这些错误观念。通过提问来get real，如：我的结论和现实相关吗？那合理吗？我忽略了什么重要的东西吗？什么重要事情还是我需要考虑下的？我扭曲了哪些事实来导致不必要的消极情绪？当我们恢复了理智，我们感受不到同种程度的同种情感。 Focus对幸福而言，人们感知世界的方式比客观环境更重要。如很多看上去拥有一切的人实际很痛苦，而有些一无所有人的人却从未停下为生活欢庆。Happiness is not contingent on our status, or our state of bank account. It’s much more dependent on our state of mind, on what we choose to focus on.We very often create our own reality. If we understand that, we can transform, we can change the way we perceive, change our focus.(我们很多时候觉得生活有问题，是因为注意力只集中在不能解决的问题上）两种类型的人，fault-finder, benefit-finder. fault-finder只将注意力集中在问题上，于是他们经常会碰上糟糕的同事、上司、餐馆。benefit-finder将注意力放在生活的光明面。 影响长寿的因素：积极、乐观的心态。具体做法：病人如癌症患者，如果更集中注意力至生病带来的好处（如家人的陪伴，关系更亲密，更珍惜生活），保持积极心态，生存率往往更高。 既然乐观，积极心态有诸多好处，2quesions：1、为什么不是每个人都是乐观主义？乐观主义有时被认为是脱离现实的（detached），媒体担有一定责任。The media focus, highlights the negative. 如，只报道父母抛弃子女的案例，不法商人获利 “Focus creates reality”（事实上这部分的观点我不太同意。媒体当然只关注异常，值得关注的新闻。父母与子女其乐融融是大部分情况，没有新闻点，而且，媒体关注，实际上是群众关注的结果。不过确实负面新闻多了也会对人有不好的影响，形成错误的schema，如进入政界，进入商界，需要尔虞我诈，但这种schema的形成不仅仅与新闻媒体有关）2、如何变成乐观主义？Correcting the false schema:1）关注正面新闻：网站good news network；2）从艺术中学习：艺术将美的一面表现出来，关注美 关于适应（Adaptation）1) We are change detectors. So we can survive better. (这也是新闻多半是负面的原因，我们对多的，好的事情习以为常，不能引起我们的注意)2) We can adapt, and that is a good thing. （Tal失去了最亲密的朋友，“Qhat I’m going to tell you now is not going to make sense. But it’s true, you are going to get over this. I know you are. We get over losses. It’s difficult, it’s painful, cry, give the emotions their spaces. But you are going to get over it. We get over painful emotions, we all do. Because if we hadn’t, God help us all.”）3) We adapt and will take things for granted, which is not a good thing. 只有当身边人有健康问题，我们才会appreciate健康，只有当我们经历过危险，失去了身边的人我们才会appreciate 生活。一定要等外界发生不寻常，厄运发生时才会感激习以为常的东西。——我们应该把感激当成一种习惯。 培养感激的习惯1）审视平凡的一天，有什么是你不自觉就会处理，不费力气就可以全身心投入的。也许是早晨的第一杯咖啡，或是带你的狗出去散步。每天找出这样的一两件事，有意识地去做它，怀着感激之心。 培养感激的习惯需要我们一次一次的联系，直到它变成我们性格的一部分。(重点在有意识地去做，do it mindfully，注意以前没有注意过的事情，发现新的特点)2）每天撰写感激清单。是Tal老师坚持了十几年的习惯。 每天做，就会变成我们性格的一部分3）Tal每天问孩子”what is fun today?”，和妻子也有这样的积极互动机制。 （do it mindfully）4）Visualizing it。孩子的视觉化很强，单词在脑海中以图片呈现，所以他们才想的慢，每件事都那么新鲜，所以他们才会appreciate简单的事情，看到飞机都那么开心，有童真。而我们长大成人后对这些都麻木了，破除麻木的一种方式就是视觉化，在脑海中形成图片，像孩子那样去看待事物。当你回想今天吃的一餐好吃的饭，在脑海中描绘它的图片并尽量真实，当你想你男女朋友的时候，在脑海中想象他们。We would all look up and praise the glory of the world, but because they shine every day, we take them for granted. For children, that don’t exist, one of the reasons is that they don’t think automatically, conceptually. They think more perceptually, sensually. They are connected to the real. And we can do it simply by visualizing it. 想着自己负面经历让情况更糟，但是分析负面情绪则相反（找出解决措施），谈论（口头或者书面）负面经历或情绪让情况变好：越战老兵30%得PTSD（Posttraumatic stress disorder），而经历大屠杀的得病比例小的原因。 越战是遭到反对的战争，老兵回国后往往不会公开谈论这段经历，他们反复回忆（replay）这段经历。体现了与朋友／心理治疗师聊天／写日记的作用，对负面情绪起到有效的干预。analyze vs simply replay。 When we analyze an experience, it helps. When we feel we can talk and analyze about painful emotion, we feel better. When we simply sit down and ruminate about painful emotions (replay) without making sense of it, we get very often it a downward spiral. Change 我们的不同想法和理解激活的是不同的神经元，把对问题看法或理解看做是河流，每当我们多使用一块区域的神经元，河流就会一点点拓宽，反之，不这么去理解，河流就会变窄。当我们换一种理解方式，就会重新开发一条河流。我们会习惯性的偏向最宽的河流，如果一个人是悲观思维，问题出现后会习惯性悲观理解，所以这也是锻炼自己换种思维方式，也是克服惯性思考的重要性。 改变的两种方式：Gradual change &amp; acute change 两种改变方式都不是突变的过程，改变的过程是缓慢的，对很快改变的期望反而会导致失望和焦虑。“The belief that we can rely on shortcuts to gratification and bypass the exercise of personal strengths and virtues is folly. It leads to legions of humanity who are depressed in the middle of great wealth and are starving to death spiritually.” 改变之前需要问的问题：1、是否真的想改变 2、觉得改变的成功率多大；对于问题1，很多人的答复是，当然是想要改变的，但是仔细想想，确定吗，我们的潜意识可能在说相反的事情。很多情况下你想要摆脱的负面性格都与你欣赏的正面性格相关。如，你重视自己被信任的品质，就可能会轻信人；你认为责任感很重要，所以你很多时候都会焦虑；这种相连会在潜意识阻挡你的改变，应该试图把二者拆分，我们需要搞清楚，我们想要摆脱的究竟是什么；（链接的练习帮助识别想要摆脱的品质和想要保留的品质Sentence Completion I 影响幸福的三大因素1）基因——决定50%的幸福程度。迈克乔丹如果不学打篮球，我可能比他打得好。如果我们不对幸福做努力，就算基因占优，也未必会幸福。2）外界环境——10%。 如果不是出于极端的点，如无家可归，环境、外界条件对人幸福感的影响并不大；3）内在的活动Intentional activities——40%。What we do, how we act, what we think about, how we interoperate the world, what we focus要改变习惯，只关注情绪不行，只关注行动也不行，只关注思想也不行。必须同时关注ABC三者：Affect, Behavior and Cognition。 峰值体验&amp;峰值体验后通路如同创伤会有PTSD，peak experience之后也可以有峰值体验后通路，如何提升峰值体验的几率：1、permission to be human：如果我们不give us permissions to be human， we’ll block emotions pathways, and positive emotions and negative often flow through the same emotions pathways. When we limit one, we often limit the other. When we open up, we are more likely to experience positive emotions.2、mindfulnessQuantity affects quality. 妈妈没有很enjoy跟孩子在一起的时光，因为她们不是全身心投入的，带孩子时接电话讨论工作，跟朋友聊天等； 很多事情可以带来乐趣，但是同时做反而会让幸福感降低。如同时听你最爱的两首歌。——too much of a good thing.(过犹不及) 如何提升峰值体验后通路的几率：1、重演画面。大脑不能区分想象和真实，在重演的过程中，神经通路得到了巩固。2、write it down.（注意正面情绪要描述而非分析）3、take action 巩固最初的体验。 Behavior: Taking Action。听完培训班后都会有peak experience，但会回到幸福基准点，有小部分学员同样回到基准点，但他们的基准点较之前有所提升。原因是做练习，运用于实践中，即take action. 他们不会等所有课听完了再整理，反省人生，而是能做的立马去做，去实践。态度和行动是相互影响的，这是长期改变产生的方法和原因。态度会影响行动，动也影响态度。这源于大脑的平衡机制：现实和头脑中的要努力保持一致。习惯是行动的汽油。态度性的改变先行，继而影响到行为性改变。微笑的动作会影响使心情变好。关押战俘的人，改变了朝鲜战争期间的美国战俘对共产主义，对中国的印象。让犯人给家人写信时只写共产主义的优越性（并不撒谎），定期分组讨论共产主义的好处，久而久之，犯人的态度发生了改变。脸部回馈说，身体回馈说：表情被真实情绪所影响，真实情绪也会被表情所影响。假装开心，也会真的让人感觉好些。体态骄傲自信，就会感觉更加自信。——体态、握手的力度都会给人传达你给人的印象，这个印象同时也会影响到你自己。先塑造行动，然后行动塑造我们。 comfort zone—— optimal discomfort zone——panic zone我们大多数人大多数时间都在舒适区，舒适区很好，但处在舒适区时，很少发生改变——跳出舒适区，来到拉伸区，拉伸区是实际发生改变的地方——再越过一点就到了恐慌区。“you can think about it all day long, and nothing will happen, unless you bring about actual real behavior change” 大脑不能分辨想象和真实。当我们害怕，很难行动的时候，利用内部模拟器——比如害怕登台演讲，想象自己为讲座做准备，想象自己顺利进行演讲，会感觉更自信。这是好的开端，虽然不足够， 但是也很实用。 人们往往依赖自律来进行改变，往往会失败。很少有人完成他的新年计划。刷牙很重要，早上我们睡眼惺忪，无力做任何事情，也能完成刷牙。锻炼很重要，但往往没法儿坚持。（对这点很有体会，长久地做一件事情，依赖意志力是很难的，更多是把它变成一种习惯（ritual），而不是一种完成任务的心态。村上在《当我谈论跑步时谈论什么》也说过。跑了十几年的步，并没觉得跟意志力有很大关系，更多是跑步合乎他的性情，至少不那么痛苦。以及，长期作业的节奏很重要，一旦节奏得以设定，其他不外是在惯性的齿轮上转动，一切问题迎刃而解。TAL老师坚持打壁球很多年也是一样的道理。）那么重点就是建立ritual，维持ritual不需要很多自律，建立ritual需要大量自律。建立ritual需要三十天（general saying），重点是在三十天内不要建立多个ritual。这也是为什么我们经常列出长长，需要改变的表，实际上没有任何改变。one by one，一个个来建立，来改变。“Incremental change is better than ambitious failure.” “Success feeds on itself” Cognition: Thoughts Create Worldsthe way you interprete things测量两组酒店服务员的身体指标，干预组告知他们研究每个动作消耗的卡路里，让人明确的知道自己在运动和消耗，这样进行8个星期之后，发现对比control group，干预组身体和心灵的健康指标全部都上升了。这说明身体的运动（behavior）配合到大脑对运动的认知和理解（cognition）将改善身体的状况（affect）。 Acute Change: The Eureka Experience（相当于Aha moment，灵光闪现）1）Aha moment来源于努力投入的日积月累。2）创造力出现的过程：preparation—immersion， incubation—idle time。3）独处时光什么也不做take time off 非常重要，让头脑休息，消化。3）原理：潜意识时间让它们形成答案或方案，潜意识完成之后就会提交，也就是灵感来临的时刻。4）前提：努力学习和积累，有量变才会有质变。 Journal对于开心的事情，要写下来不作分析，只是replay，加强体验；对于难过的事情，要进行分析；不要压抑，要表达并不是改变成功了才有乐趣，the process itself is very rewarding. It’s the process, not the outcome that matters more. The outcome will lead to a spike but will very quickly go back to our base level. the key is 对我们现在正在做的事的投入。设定目标，全心投入才是最重要的。 Set goal:1、让我们更专注目标让我们专注：我们四处奔波，不知道自己的方向，而不知道方向就不可能达到目的地；就像旅程一样，如果目的地明确，会更好地享受途中的风景，目标也是一样，有了目标，人生才会更幸福，更多彩。这解释了为什么很多人退休以后反而变得不够快乐，而那些快乐的人，对自己设置了目标，不管是上门课，学新知识，还是更多的陪伴家人，而不是“享受生活，顺其自然”的态度。我们需要目标、结果、生活的导向。2、提高适应能力3、设定目标有助于成功， 尼采：When we have what for, every how becomes possible.只要我们有目标，一切就有可能。 当我们设定目标时候，同信念自我实现差不多，有目标表示我们相信自己会得到某样东西，我们的大脑不喜欢想象和真实的不一致性，更有可能成功。 此外，当我们设定目标的时候，我们会关注目标的达成，因为会关注到之没关注到的资源，感觉是便是甚至于资源都会向我们倾斜。如，当我们说自己要买电脑的时候，就会看到到处都是电脑广告，而以前根本没关注过。 追寻目标的过程，相较目标实现，更成为实现幸福的关键。很多很成功的人不开心，是因为他们把目标的实现当成幸福的关键，实现目标会带来幸福的spike，但很快回归基准线，这时候就会感到迷茫。 设定自我和谐的目标：make a list of what i can to——choose what i want to do —— choose what i want to do the most“Life is too short to do what i have to do, it’s barely long enough to do i want to do.” The sooner we start on the want-to, the better. 如果说，你发现自己的兴趣是做生意，为了筹备资金你可能会做一些你不愿意做的事情，这很正常，延迟满足，但问题在于我们常常处于无止境延迟满足的状态。 No pain, no gain. WRONG——Do it better with pleasure.涓滴效应：当你设定一个自我和谐的目标 并为之努力的话，你很大可能在其他的方面也做的不错。因为generally你更motivated，更excited，更enjoy life with passion。 Principals of setting goals:1、Write them down.Writing them down is making a promise.说出来不够，在心里想不够，一定要写出来；2、设定期限relate to date, make goals specific. I want to become fit–rather than the generic “I want to become fitter”——I’m going to run 5 miles, 4 times a week by October,15th.3、一步步来，将成功细化，会更感觉那是有可能的，也就更容易达到目标。向两组学生介绍一群杰出的科学家，让学生对其进行评价并评判自己是否可以达到其高度。A组仅介绍了成就，B组还介绍了科学家达到成就的过程和细节，他的挫败失望等，两组均对科学家评价很高，但B组更多的人认为自己可以努力达到其高度，而信念即自我实现。have a long-term goal——break it down to short-term/medium-term goal——make plans——creat rituals based on the plans. Value in action:identify your strength and value——builiding capacity and problem-solvinghow to find your personal strength?1、by asking, is this the real me ?2、The best way to define a man’s charateristic would be to seek out the particular mental or moral attitude in which, when it came upon him, he felt most deeply and intensely active and alive.——feel like the real me.3、online test：www.viastrengths.org 找出你的top virtue strength后，将注意力放在其上，在生活中运用它们，利用它们来解决生活中遇到的实际问题 ，提高幸福感 。（如，tal老师在重复开设某个课程第三次后，感到精疲力尽，无力继续-因为love of learning在他的via中排第二，重复教授课程与其不符，于是他便每天抽出一小时学习新东西。又如利用学习新东西的热爱来改善自己的焦虑——学习缓解焦虑的书）Instead of focusing on what you can live with, we should be thinking about what we can’t live with. Stress is not the problem. The problem is lack of recovery. 就如同举重，也是向肌肉施加压力，但只要你不是缺乏休息，过度运动，便没有很大的问题。在为某事投入精力的时候，短跑冲刺的方式比马拉松更适合。某一段时间集中投入精力，然后休息。比如，一个半小时全心全意投入，然后休息十五分钟。此外，要注重灵活性，如定下目标一周完成11个一个半小时，或许有其他临时的杂事干扰，但灵活分散安排11个一个半小时。当你完成这11个的目标时，首先因为你的投入会有收获，其次也会有完成的满足感和成就感。 过犹不及：同时听你最爱的两首歌，它们反而变成了噪音，同理，当你在陪伴自己的孩子，与朋友聚餐，做通常自己爱做的事情时，因为别的事情分神，查邮件，想着工作没做完的事情，不会有办法享受正在做的事情，而这明明是喜欢做的事情，这样会造成困扰,重点是Focus；Quantity affects quality. 创造力、效率、幸福感与工作量是抛物线的关系，工作量太低，创造力等会比较低下，工作量太高，幸福感也不高。一点点空气也会充满整个屋子，即使工作再少，也会占用我们一天的时间，于是我们效率低下，没有创造力，也不开心； 拖延症：1、five minutes start-up：很多时候我们以为要有灵感才能做要做的事情，但其实事实是做起来才会有灵感。对于想要拖延的事情，先做五分钟，先行动起来，这五分钟会产生upward spiral2、reward 做到了的话，要给自己奖励3、go public 破釜沉舟4、do it with people 比如去图书馆自习 完美主义：The greatest mistake a man can make is to be afraid of making one.(Learn to fail or fail to learn)有心理安全感的组织，雇员不会害怕告密，不害怕犯错，这些组织往往更成功。－－学习型组织，雇员不怕犯错，从错误中成长，下次就能做的更好－－对父母也是同样的道理，如果孩子有足够的安全感，愿意敢于跟父母谈论自己的失败，错误，他们就不容易变成害怕失败的完美主义。 完美主义:一种充斥在我们生活中的对失败的失能性恐惧,尤其是在我们最在意的方面.达到成功没有直线的捷径，完美的恋情没有直线的捷径，必定会犯错。抱有直线捷径的schema 不现实，也注定会带来受挫感及失望；从A到目的地B没有直线的直径。 有雄心壮志，而非完美主义的人并不是不在乎目的地B，他们同样在乎从A到B的旅程。上一些课程，看一些作品，参加一些活动，重视这样的经历，而不是把他们当做我为了成功，为了达到目的地B必须经历的事情。（既然已经在做一件事，还不如百分百沉浸，并尽力把它做好） 完美主义的坏处：1、完美主义者不接纳自己；2、我们对世界的看法与对自己的看法一致，我们对自己期待完美，对周边的人，发生的事物也是同等要求；3、完美主义让人瘫痪：当我们为失败所困扰，我们就更不会采取行动。完美主义是事情耽搁的一大主要原因，对失败的失能性恐惧。 Self concept is destiny. lucky factor: 获得更多运气的关键，尝试新鲜不同的事物，哪怕是在去学校的路上选择一条没有走过的路，因为我们开始看见之前没看过的洞悉， 不应该仅仅对终点的成功进行赞赏鼓励，还应该对付出的努力，失败后的应对措施进行鼓励。当我们仅仅着重于天赋的时候，我们就在制造完美主义的基模，而不是注重旅途，注重成长的基模。如果称赞孩子的智力，当他们失败时，他们会认为自己不再聪明，从而失去对眼前工作的兴趣。而那些被称赞努力的孩子，在困难面前不会气馁，反而更有动力。重视努力给孩子提供了可以让他们自己掌控成功的变量。 困难环境下的小技巧： permission to be human: 任何一件叫人沮丧，负面情绪的事情发生的事情的第一反应——我所有的反应，所有的情绪都是正常的； positive：我能从中学到什么？ &amp;Distraction 并不是时刻分析自己的情绪和想法都是有利的，我们需要适当转移注意力，如听音乐，跑步，这不意味着逃避，而是等待情绪冷静； change of perspective: 心理成熟就是根据自己意愿来转换视角。Psychological maturity is the ability to willingly shift perspective. Is this really going to matter a year from now?长远看来它的影响大吗？ zoom out—我现在需要为它伤神吗？ 我什么时候想要沉浸于当下？ 关于心理健康，我们对于认知心理关注的过多（neck-up），而对身体健康对心理健康的关注过少（neck-down）（健康不能被看做身体或者精神的单独属性，因为身体和精神是内在联系的）运动和冥想：Tal 推荐的wonder drug1、每周3-4次半小时以上锻炼2、每周6-7次15分钟以上冥想3、每天8小时及以上睡眠 锻炼可以带来诸多好处，提升self-esteem，而且是自然需要，但很难坚持。因为相比较坐在沙发上玩游戏，看电视，锻炼的确是painful的。尤其当你定下严格的计划，并且逼迫自己执行，当因出差等外界因素停止一周后，就更难继续了。此时在在心里已经把 excercise跟pain对等了起来，而人向来是趋利避害的。正确的做法的循序渐进，逐渐体会运动带来的益处。当你已经习惯运动的时候，实际上就成瘾了，不运动反而感觉缺了点什么。另外，在做在你看来boring的运动时，注意引入distraction，比如听歌，听电子书等。（有体会，跑步时候反而不喜欢听歌了，喜欢散漫地东想西想，跑的最轻松的时候往往是走神走得厉害，都已经忘掉在跑步这件事情）。此外，对运动常见的借口是没时间，但这是一项收益巨大的事情，必须得挤出时间。另外实践证明，时间最多，反而是最懒散的时候。 锻炼需要注意的：1、注意保持频率2、不要过犹不及 少量比过量好3、注意休息，恢复期 各种冥想的共同点为：将注意力集中在一件事情上。冥想的基础是深呼吸。冥想没有好坏，不要带着目的性去冥想。冥想时关注于此时此刻，思维涣散了将它拉回来即可，这就是练习的过程。 当我们练习mindful therapy（正念冥想）时，我们的注意力从doing转换到being上面来， 建议：每天多次练习深呼吸。起床后，睡觉前三次深呼吸，等等。把遇到红灯当作是练习呼吸的机会，不管在车上还是在路边，注意力放在呼吸上，slow and deep 睡眠：每天睡够八小时感觉没这么多时间，但如果把它看做投资，一定可以挤出时间。like，要你拿出一百万，你拿不出来，但如果你拿一百万每年有20%的收益，你一定会拿出来来。——提高睡眠的优先级睡眠足够的好处：显著增强免疫系统睡眠不足导致体重增加提高生产力、创造力带着问题入睡，醒来时往往得到解决 睡不着时候的“permission to be human”睡不着时候想着我要赶紧睡着我要赶紧睡着跟演讲前想着不要焦虑一样，“pink elephant”睡眠时间没法保证的时候take naps Touch：现状：We don’t touch enough, it is physical need like sleep, food and exercise.How important of touch:1) 提高免疫系统；2) 对伤病有帮助；3）智力发展（小孩）；4）压力缓解；5）性功能障碍绝大多数可通过touch解决，同时也能增强性生活的质量；6）多触摸小孩对小孩的发展非常有帮助；这是人天性的需要；7）we need 4 hugs a day for survival, 8 hugs a day for maintenance, 12 hugs a day for growth. 每天至少5个拥抱给不同的人（non-sexual hugs)，试验者变得更加幸福和快乐。8）拥抱是win-win双赢的事情，当你抚摸的时候，你也是被抚摸的 关于健康，Tal教授给的处方：1）一周至少4 次 30分钟以上的运动；2）每天mindful exercise冥想，10-15分钟，如果做不到，就做几个深呼吸；3）每天晚上8小时睡眠；4）每天至少5个，最好能12个拥抱。 Love Top10%更幸福的人都有一段稳定亲密的关系。这段亲密关系让我们分析快乐时快乐放大，倾诉悲伤烦恼时得到缓解。（通常男性从一段亲密关系中获益更多，因为女性本来便较为习惯向友人分享）。 人际关系中的重点是认清自己， 即了解自己的需要，每个人需要的人际关系都不一样。千层面理论：很爱吃千层面，也不能天天吃。你要了解自己的份额，与别人相处多久对你是恰当和舒适的。 Exotic is erotic, novelty excites. 哪怕你的对象完美如布拉德皮特，相处五年后，一个moderately attractive的男性给你带来的physical arousement更多。Is it bad new? It’s not bad or good, it’s just nature.——人类的适应性。（虽然人类适应性强大，虽然一百分完美的生活也会很快被适应，被认为理所当然，但这并不意味就该满足现状。八十分的生活与一百分的生活当然有差别，还是应该向更好的追求。不如把适应性更多用在面对困难，情绪低落时候） “Perfect love is rare indeed- for to be a lover will require that you continuely have the subtlety of the very wise, the fexiblity of the children, the sensitivity of the artist, the understanding of the philosopher, the acceptance of the saint, the tolerance and the fortitude of the certain.”没有完美的爱情，作出以上期许必定会失望。虽然完美的爱情不存在，但是ture love exists. True love exists between imperfect humans. 什么是真爱？如何找到真爱？1、问对问题Questions define reality. 相比较“为什么这么多婚姻会失败”，更应该问“什么让一些关系发展良好，并随时间越来越好”2、不仅关注what works，还要关注what works best. learn from the tips of the stem. 1、Working hard维持恋情需要努力。if you want to get good results at work, you need to work hard. if you want to thrive in a relationship, you need to invest. Cultivating versus Finding：很多人拥有不正确的期望，大多数人认为婚姻美满最重要在于选择对象“finding mindset”，然而存在“finding mindset”的固定心智会损害婚姻，类似完美主义的危害。存在finding mindset的人容易放弃婚姻，而不是努力改善婚姻。没有完美的婚姻，不存在。正确的应该是“cultivating mindset”，培育婚姻。 （同要夸学生努力而不是聪明） Being Together By Doing Together：真爱是两个人一起设置共同目标（Mutually meaningful goals），working together, support each other and it will make the relationship stronger. 爱情不仅仅是在一起，而是支持彼此的理想和抱负，并且在生活中融入共同的目标。 保存主动付出：心理推动行为，行为反过来又会塑造心理。如果一段感情中我们投入不多，我们就会潜意识认为这段感情不重要，love will wane。而投入的越多，潜意识认为更重要。 如何主动付出： 建立 relationship rituals。 比如每周要跟恋人共进晚餐，约会一次。如果没有ritual，生活中重要但不紧急的事情就会被忽略。 2、making the shift from the desire to be validated to the desire to be known.重要性： 让伴侣更喜欢我们。因为建立了更深层次的亲密关系，虽然他们可能对我们被了解的那点不喜欢或者不欣赏，但久而久之，真诚的人更attractive（不能用伴侣暴露的弱点来指责或伤害他） 如果我们是要被validate，而不是真实的我，被人喜欢也不是喜欢真正的我，感情不会长久 Cultivate relationship: get to know more about one another, share more things. Ideal relationship is to express ourselves rather than impress. It is more risky to open up, but it is worthy. If we want to impress, we will guarantee failure 3、Allowing conflict in relationships允许冲突发生。重点不是消除负面的东西，而且强化巩固积极的部分。（Gottman）幸福助听器（《Happier》）:love is in the details. What sustain a happy relationship are the details. The day to day rituals, the touch, the gaze, the meal together.迷你爱情助听器：一天中30s的pleasure joint——a passionate kiss、a hug、a text messages telling how much you love your partner, etc.——little things make big difference. Big things make big differences too, but that just leads to a spike, to sustain happiness.注重生活中的琐碎小事——demonstrate interest—— by asking questions: how was your day? you look down, is there anything i can do ? etc. ——get to know the other person, what they like, what they don’t like, how they like them.Pay compliment——dont take everything for granted. Healthy confilict is cognitive conflict rather than affective conflict. Cognitive conflict is about focusing on the person’s behavior, or thoughts and ideas, and challenging those. Unhealthy conflict is focusing on the person, on the emotions, on who they are. “你为什么不把马桶盖放下来”（针对行为）VS“你真是非常不为他人考虑”（针对个人）尽量避免恶意、侮辱及蔑视keep disputes private 双方的私人情感不要放在公众面前 4、Positive perception: Appreciate the positive Happy marriages are based on a deep friendship.–John Gottman, by this I mean a mutual respect and enjoyment of each other’s company, these couples tend to know each other intimately.They have an abiding regard for each other and express the fondness not just in the big ways, but in little ways day in and day out. In a healthy relationship, the partners have to be the beneift finder. They have to appreciate one another. 更进一步，不仅要做benefit finder，还要做benefit creator。 对自己的伴侣做出评价，那些评价比与ta亲近的人如亲戚朋友，作出评价更高的人，两人的关系更美好。心理学家称之为“积极的错觉”。但这只是部分正确，因为不能完全称之为错觉，因为Beliefs as self-fulfilling prophecies，信念即自我实现。 Not only does love perceive potentialities, but it also actualizes them. “you make me want to be a better person”——beautiful enemy. Not only love you, care about you, but also push you, challenge you. 爱人不仅仅是顺着你，还应该是supportive challenging，让你向更好的方向发展。 与爱人间的沟通： active constructive Self-esteem自尊是什么？ 自尊是对自我的评价和感受。1）定义：自尊是一种有能力应对生活基本挑战和值得拥有幸福生活的自我体验的倾向。“Self-esteem is the disposition to experience oneself as competent to cope with the basic challenges of life and as worthy of happiness.” —-Nathaniel Branden。一是有能力感，二是有价值感。 “Of all the judgements we pass in our lives, none is as important as the one we pass on ourselves.” 我们在生活中作出的所有判断，没有哪个比对自己作出的判断更重要的。因为我们时刻有自我意识，它影响我们生活中的各个领域。Self concept is destiny. 高自尊带来的好处：1 、心理健康：higher levels of resilience, dealing with difficulties.2、relationship improvement. 建立自尊的重要实践：1、正直；integrity means a match between what we say and what we do.言行一致。如果言行不一致，那我们就是在对自己说，我说的话无关紧要——我不重要。不要撒谎，撒谎说明我们对现在的自己不满意，需要撒谎让自己看上去更好。并且撒谎要付出心理及情绪上的代价。2、建立自我协调目标；努力追求，有目标有使命地生活3、take responsibility4、the practice of self-acceptance ——permission to be human5、要有主见，say yes／no when it’s appropriate, stand up for what we believe. 自尊的三层：依赖型自尊、独立型自尊、无条件型自尊。逐渐发展自尊的两个组成部分：价值感worthiness、能力感competence依赖型自尊：价值感需要从他人评价中得到，能力感跟他人比较中得到。独立型自尊：不需要从他人评价中得到，自我生成。价值感从自我评价中得到，能力感与自己对比中得到（今天的我是否比昨天有进步）无条件型自尊（unconditional）：不依赖任何评价 独立自尊的人更平静（运动促进calm） 想象你在一个没人看得到你，没人知道你成就的地方，你做的事情，没人认可，点头，称赞，你仍抱有很大热情去做的事情是什么。 三层自尊由下至上层层推进发展，不可跨越，每个人都会包含这三种类型自尊，只是程度的问题。 依赖型自尊并不是不好，part of human nature，抵抗反而会让其增强，permission to be human。 Courage is not about not having fear, it’s about having fear and going ahead anyway.","tags":[{"name":"哈佛幸福果","slug":"哈佛幸福果","permalink":"http://willxue.top/tags/哈佛幸福果/"}]},{"title":"位图法","date":"2017-04-08T03:47:40.000Z","path":"2017/04/08/位图法/","text":"位图法一、位图法定义所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。例如，要判断一千万个人的状态，每个人只有两种状态：男人，女人，可以用0，1表示。那么就可以开一个int数组，一个int有32个位，就可以表示32个人。操作的时候可以使用位操作。 二、 位图法原理位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位图数组中每个元素在内存中占用1位，所以可以节省存储空间。位图是一种非常简洁快速的数据结构，它能同时使存储空间和速度最优化。 如可用一个10位长的字符串来表示一个所有元素都小于10的简单的非负整数集合，例如，可以用如下字符串表示集合{1,2,4,5,8} ，对应位置数字存在标记为1，否则标记为0。 二、位图法应用1、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中申请512M的内存一个bit位代表一个unsigned int值读入40亿个数，设置相应的bit位读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在 2、使用位图法判断整形数组是否存在重复判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到 5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。 三、位图法相关的Java代码四、相关的面试题目题目1：在2.5亿整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数？如果对2.5亿个数字排序，怎么办？类似题目：给你一堆电话号码列表，数量大概在千万级，要求从中找出所有重复的电话号码，需要时间复杂度尽可能小。 题目2：腾讯面试题：给40亿个不重复的unsinged int的整数，没排过序，然后再给出一个数，如何快速判断这个数是否在那40亿个数当中？ 题目3：海量数据排序问题：文件包含1千万条电话号码记录(10**7次方)，每条记录都是7位整数，没有重复的整数。要求对文件进行排序，注意大约只有1MB的内存空间可用，有充足的磁盘存储空间可用。请设计一个高效的算法。 思路1 ：如果有足够的内存，1）按照集合中最大元素（或者集合中数据数目）max创建一个长度为max+1的数组。数组下标代表对应数字，数组各个元素值标记初始值为0。 2）赋初始值：根据数字是否在集合中在数组对应值中做标记，如在集合中标记为1 3）扫描数组：对于找数字是否在集中的题目，可以在数组对应位置查看标记是否为1，为1表示数字在集合汇总，为0表示数字不在集合中。 对于找重复数字的题目，可以在第2步赋值的时候获得如下信息：如果集合中数字在对应位置赋值时，发现数组值已为1，则这个数字是重复的，输出该数字。时间复杂度O(2N)。排序：如果排序的话，按照位图数组输出数组值为1的数组的下标就可以了。 但是现在的问题是当数据量很大时，内存无法存放如此大的数据量。如用整型数组存放10000000000个数字，JAVA中整型是4个字节，所以共占用内存40GBint[] a = new int[10000000000];boolean[] a = new boolean[10000000000];思考：如何解决？因为我们在数组的值中只需存取值0和1，所以最简单的0和1就够用了，能表示0和1的最小存储单位是什么呢？是内存中的一位。所以可以用位图数组大大减小存储空间。 思路2 ：可以用外部排序（合并排序），然后查找的方法 其他应用：设计搜索剪枝时，需要保存已经搜索过的历史信息，有些情况下，可以使用位图减小历史信息数据所在空间。","tags":[{"name":"算法","slug":"算法","permalink":"http://willxue.top/tags/算法/"}]},{"title":"sort-half-billion-numbers","date":"2017-04-08T00:31:49.000Z","path":"2017/04/08/sort-half-billion-numbers/","text":"5亿整数的大文件，怎么排问题给你1个文件: bigdata，大小4663M，5亿个数，文件中的数据随机,如下一行一个整数： 1234567891011121361963023557681612158020393452095006174677379343122016371712330287901712966901...7005375 现在要对这个文件进行排序，怎么搞？ 内部排序先尝试内排，选2种排序方式： 3路快排：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private final int cutoff = 8;public &lt;T&gt; void perform(Comparable&lt;T&gt;[] a) &#123; perform(a,0,a.length - 1); &#125; private &lt;T&gt; int median3(Comparable&lt;T&gt;[] a,int x,int y,int z) &#123; if(lessThan(a[x],a[y])) &#123; if(lessThan(a[y],a[z])) &#123; return y; &#125; else if(lessThan(a[x],a[z])) &#123; return z; &#125;else &#123; return x; &#125; &#125;else &#123; if(lessThan(a[z],a[y]))&#123; return y; &#125;else if(lessThan(a[z],a[x])) &#123; return z; &#125;else &#123; return x; &#125; &#125; &#125; private &lt;T&gt; void perform(Comparable&lt;T&gt;[] a,int low,int high) &#123; int n = high - low + 1; //当序列非常小，用插入排序 if(n &lt;= cutoff) &#123; InsertionSort insertionSort = SortFactory.createInsertionSort(); insertionSort.perform(a,low,high); //当序列中小时，使用median3 &#125;else if(n &lt;= 100) &#123; int m = median3(a,low,low + (n &gt;&gt;&gt; 1),high); exchange(a,m,low); //当序列比较大时，使用ninther &#125;else &#123; int gap = n &gt;&gt;&gt; 3; int m = low + (n &gt;&gt;&gt; 1); int m1 = median3(a,low,low + gap,low + (gap &lt;&lt; 1)); int m2 = median3(a,m - gap,m,m + gap); int m3 = median3(a,high - (gap &lt;&lt; 1),high - gap,high); int ninther = median3(a,m1,m2,m3); exchange(a,ninther,low); &#125; if(high &lt;= low) return; //lessThan int lt = low; //greaterThan int gt = high; //中心点 Comparable&lt;T&gt; pivot = a[low]; int i = low + 1; /* * 不变式： * a[low..lt-1] 小于pivot -&gt; 前部(first) * a[lt..i-1] 等于 pivot -&gt; 中部(middle) * a[gt+1..n-1] 大于 pivot -&gt; 后部(final) * * a[i..gt] 待考察区域 */ while (i &lt;= gt) &#123; if(lessThan(a[i],pivot)) &#123; //i-&gt; ,lt -&gt; exchange(a,lt++,i++); &#125;else if(lessThan(pivot,a[i])) &#123; exchange(a,i,gt--); &#125;else&#123; i++; &#125; &#125; // a[low..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..high]. perform(a,low,lt - 1); perform(a,gt + 1,high); &#125; 归并排序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 小于等于这个值的时候，交给插入排序 */ private final int cutoff = 8; /** * 对给定的元素序列进行排序 * * @param a 给定元素序列 */ @Override public &lt;T&gt; void perform(Comparable&lt;T&gt;[] a) &#123; Comparable&lt;T&gt;[] b = a.clone(); perform(b, a, 0, a.length - 1); &#125; private &lt;T&gt; void perform(Comparable&lt;T&gt;[] src,Comparable&lt;T&gt;[] dest,int low,int high) &#123; if(low &gt;= high) return; //小于等于cutoff的时候,交给插入排序 if(high - low &lt;= cutoff) &#123; SortFactory.createInsertionSort().perform(dest,low,high); return; &#125; int mid = low + ((high - low) &gt;&gt;&gt; 1); perform(dest,src,low,mid); perform(dest,src,mid + 1,high); //考虑局部有序 src[mid] &lt;= src[mid+1] if(lessThanOrEqual(src[mid],src[mid+1])) &#123; System.arraycopy(src,low,dest,low,high - low + 1); &#125; //src[low .. mid] + src[mid+1 .. high] -&gt; dest[low .. high] merge(src,dest,low,mid,high); &#125; private &lt;T&gt; void merge(Comparable&lt;T&gt;[] src,Comparable&lt;T&gt;[] dest,int low,int mid,int high) &#123; for(int i = low,v = low,w = mid + 1; i &lt;= high; i++) &#123; if(w &gt; high || v &lt;= mid &amp;&amp; lessThanOrEqual(src[v],src[w])) &#123; dest[i] = src[v++]; &#125;else &#123; dest[i] = src[w++]; &#125; &#125; &#125; 数据太多，递归太深 -&gt;栈溢出？加大Xss？数据太多，数组太长 -&gt; OOM？加大Xmx? 耐心不足，没跑出来.而且要将这么大的文件读入内存，在堆中维护这么大个数据量，还有内排中不断的拷贝，对栈和堆都是很大的压力，不具备通用性。 sort命令来跑1sort -n bigdata -o bigdata.sorted 跑了多久呢？24分钟. 为什么这么慢？ 粗略的看下我们的资源： 1. 内存 jvm-heap/stack，native-heap/stack,page-cache，block-buffer 2. 外存 swap + 磁盘 数据量很大，函数调用很多，系统调用很多，内核/用户缓冲区拷贝很多，脏页回写很多，io-wait很高，io很繁忙，堆栈数据不断交换至swap，线程切换很多，每个环节的锁也很多. 总之，内存吃紧，问磁盘要空间，脏数据持久化过多导致cache频繁失效，引发大量回写，回写线程高，导致cpu大量时间用于上下文切换，一切，都很糟糕，所以24分钟不细看了，无法忍受. 位图法以下代码不支持重复数据排序，但位图法可以拓展支持重复.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private BitSet bits; public void perform( String largeFileName, int total, String destLargeFileName, Castor&lt;Integer&gt; castor, int readerBufferSize, int writerBufferSize, boolean asc) throws IOException &#123; System.out.println(\"BitmapSort Started.\"); long start = System.currentTimeMillis(); bits = new BitSet(total); InputPart&lt;Integer&gt; largeIn = PartFactory.createCharBufferedInputPart(largeFileName, readerBufferSize); OutputPart&lt;Integer&gt; largeOut = PartFactory.createCharBufferedOutputPart(destLargeFileName, writerBufferSize); largeOut.delete(); Integer data; int off = 0; try &#123; while (true) &#123; data = largeIn.read(); if (data == null) break; int v = data; set(v); off++; &#125; largeIn.close(); int size = bits.size(); System.out.println(String.format(\"lines : %d ,bits : %d\", off, size)); if(asc) &#123; for (int i = 0; i &lt; size; i++) &#123; if (get(i)) &#123; largeOut.write(i); &#125; &#125; &#125;else &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (get(i)) &#123; largeOut.write(i); &#125; &#125; &#125; largeOut.close(); long stop = System.currentTimeMillis(); long elapsed = stop - start; System.out.println(String.format(\"BitmapSort Completed.elapsed : %dms\",elapsed)); &#125;finally &#123; largeIn.close(); largeOut.close(); &#125; &#125; private void set(int i) &#123; bits.set(i); &#125; private boolean get(int v) &#123; return bits.get(v); &#125; 外部排序该外部排序上场了.外部排序干嘛的？ 内存极少的情况下，利用分治策略，利用外存保存中间结果，再用多路归并来排序; 1. map-reduce的嫡系. 1.分内存中维护一个极小的核心缓冲区memBuffer，将大文件bigdata按行读入，搜集到memBuffer满或者大文件读完时，对memBuffer中的数据调用内排进行排序，排序后将有序结果写入磁盘文件bigdata.xxx.part.sorted.循环利用memBuffer直到大文件处理完毕，得到n个有序的磁盘文件： 2.合现在有了n个有序的小文件，怎么合并成1个有序的大文件？把所有小文件读入内存，然后内排？(⊙o⊙)…no! 利用如下原理进行归并排序： 我们举个简单的例子： &gt; 文件1：3,6,9 文件2：2,4,8 文件3：1,5,7 第一回合： 文件1的最小值：3 , 排在文件1的第1行 文件2的最小值：2，排在文件2的第1行 文件3的最小值：1，排在文件3的第1行 那么，这3个文件中的最小值是：min(1,2,3) = 1 也就是说，最终大文件的当前最小值，是文件1、2、3的当前最小值的最小值，绕么？ 上面拿出了最小值1，写入大文件. 第二回合： 文件1的最小值：3 , 排在文件1的第1行 文件2的最小值：2，排在文件2的第1行 文件3的最小值：5，排在文件3的第2行 那么，这3个文件中的最小值是：min(5,2,3) = 2 将2写入大文件. 也就是说，最小值属于哪个文件，那么就从哪个文件当中取下一行数据.（因为小文件内部有序，下一行数据代表了它当前的最小值） 最终的时间，跑了771秒，13分钟左右. xml less bigdata.sorted.text ... 9999966 9999967 9999968 9999969 9999970 9999971 9999972 9999973 9999974 9999975 9999976 9999977 9999978 ...java 转自：foreach_break","tags":[{"name":"sort-half-billion-numbers","slug":"sort-half-billion-numbers","permalink":"http://willxue.top/tags/sort-half-billion-numbers/"}]},{"title":"MyBatis排序时使用order by 动态参数时需要注意，用$而不是#","date":"2017-03-23T13:13:49.000Z","path":"2017/03/23/MyBatis排序时使用order-by-动态参数时需要注意，用-而不是/","text":"#MyBatis排序时使用order by 动态参数时需要注意，用$而不是# 字符串替换默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全，很迅速也是首选做法，有时你只是想直接在SQL语句中插入一个不改变的字符串。比如，像ORDER BY，你可以这样来使用：ORDER BY ${columnName}这里MyBatis不会修改或转义字符串。 重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://willxue.top/tags/MyBatis/"}]},{"title":"Druid简介","date":"2017-03-18T12:36:56.000Z","path":"2017/03/18/Druid简介/","text":"Druid 简介【软件简介】 Druid 是一个JDBC组件，它包括三部分： 1、DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 2、DruidDataSource 高效可管理的数据库连接池。 3、SQLParser 【访谈实录】1. 能否先介绍一下你自己（技术背景、工作经历、学习经历）我，温绍锦，新浪微博账号是温高铁（http://weibo.com/wengaotie），2001年深圳大学毕业后到金蝶软件工作，到2010年3月，在此期间，主要的工作成果包括工作流引擎、多数据支持、短信网关、SAAS多租户技术架构等。2010年3月加入阿里巴巴至今，主要负责设计阿里巴巴的监控系统Dragoon，监控应用和操作系统以及网络设备。Druid和Fastjson都是监控系统的伴生项目。 2. 是什么促使你（团队）开发 Druid ？为什么取这个名字？在应用监控中，JDBC层间的监控十分重要，Druid就是为监控而生的。老板喜欢的一个游戏职业是Druid，于是项目的名称就是Druid。 3. 相对别的JDBC组件，Druid有什么优势和特点？有没有一些特殊或者创新的技术运用？Druid最重要的优势，就是监控和扩展。在实际测试中，DruidDataSource的性能要比C3P0/DBCP/Jboss DataSource/Proxool/BoneCP都要好，但性能不是Druid的最重要优势。Druid最初是为监控而生的JDBC组件，阿里巴巴的应用监控系统的JDBC相关监控数据都来自Druid。Druid能够监控执行时间、事务时间、返回行数、更新行数、最大并发、耗时区间分布等，共一百多个监控指标。Druid的监控非常出色，在业界中，没有任何JDBC组件在监控方面能和Druid相比。Druid提供了基于Filter-Chain模式的扩展，使得在JDBC层做扩展非常容易。Druid内置提供了一些常用的Filter，StatFilter用于提供监控数据，Log系列Filter用于提供输出Connection、Statement、ResultSet相关的日志，WallFilter用于防御SQL注入攻击。在阿里巴巴，业务系统自行开发各种功能的Filter，比如：数据库密码加密的CirceFilter、数据库修改操作变更日志记录的TracerFilter、用于关联监控统计的DragoonFilter、用于错误编码转换的EncodingConvertFilter等等。Druid还提供了一个功能完毕的SQL Parser，支持Oracle、MySQL、Postgresql、SQL Server等主流数据库的SQL。 4. Druid 目前怎么推广，在实际产品中的应用情况如何？Druid已经在阿里巴巴的B2B中全面使用，大约有600多个应用，最大的应用一个集群60多个Instance，总共数千个Instance。Druid在淘宝、支付宝刚开始使用。随着监控系统Dragoon在整个阿里集团推广，Druid将会在整个阿里集团部署。Druid在阿里巴巴外部也有很多用户，经常收到反馈，但没有详细的统计数据。 5. 阿里以外的项目比较少采用 Druid 是否因为它比较适合大型系统？因为 Druid 强大的监控功能，一般小型系统都不需要。我估计易用性和文档是大部分项目选用连接池的首要指标。不知道你是否认同我的观点？不是的，阿里巴巴600多个应用中，大中小各种类型的应用都有。稳定来自于透明，Druid的监控功能使得数据库访问层完全透明可监控。据我收到的反馈来看，阿里巴巴之外，至少有50个以上的项目采用了Druid。最近主动部署内置监控页面的，很多都是小应用，只有一台服务器的小应用。Druid的应用还没有DBCP、C3P0广，主要是它对外推广的时间还不够长，今年（2012年）下半年开始，才开始对外推广。 6. 目前参与开发/维护 Druid 的人员有哪些？是否都是全职做 Druid 的开发？目前主要的开发人员有：刘加伟（项目发起人/阿里集团）、温绍锦（我/阿里集团）、王瑾华（axmanwang/阿里集团）、张永为（sandzhang/阿里巴巴）、修斯研（xiusiyan/支付宝）、齐占明（ZhangmingQi/中企永联）、周科荣（zhouhaibin/新浪彩票）、septer。只有温绍锦（我）和王瑾华曾是公司工作安排相关，其他的都是业余参与。在2011初，公司配备了专职的连接池测试人员：王克举、陈龙（实习生），2011年下半年连接池稳定之后就没有专职的测试了。 7. Druid 将来的发展方向？成为国内使用最广泛的Java数据库连接池。着重社区建设，增加非阿里系开发人员的比重。 8. 能否谈一下你对开源的理解，以及对国内开源技术和产品的看法？参与开源是个人爱好，是对技术的追求。开源的项目，一定要是精品，要有突出的优势，把乱七八糟的产品开源了，没有意义。做开源产品，必须强调运营，和社区互动，尽量让社区更多参与其中。 ###9. 淘宝内部对于 Druid 这样的开源项目是如何管理和规划的？这个项目发源于阿里巴巴B2B，目前归属于阿里集团，不是淘宝。项目首先是服务于公司的业务，阿里巴巴开源平台是做精品策略，开源必须要是好产品。公司支持和鼓励开源，但开源部分的工作和绩效无关。Druid的发展过程中，公司配备专职的测试，在测试环境和生产环境进行测试，实施阶段有专职人员负责实施，各个部门有相应的实施负责人。Druid快速发展成熟，很重要的原因是公司提供了大力支持。 10. 你有什么建议给程序员初学者吗？如果项目中有用到数据库连接池，一定要选择Druid。多阅读JDK基础类库的源码，多阅读JSR（http://jcp.org）。 11. 能否给开源中国提一些意见和建议？建议OSChina把原来使用的数据库连接池更换为Druid。 12、开源地址APIhttp://tool.oschina.net/apidocs/apidoc?api=druid0.26 OSChinahttps://git.oschina.net/wenshao/druid github(信息比oschina全一些)https://github.com/druid-io","tags":[{"name":"Druid","slug":"Druid","permalink":"http://willxue.top/tags/Druid/"}]},{"title":"2017年书单","date":"2017-03-04T01:31:19.000Z","path":"2017/03/04/2017年书单/","text":"2017年大爷的书单 1、《解忧杂货店》 – 春节期间2、《大话Java性能优化》 –2017.02.113、《摆渡人》 –2017.03.01 2017年娘子的书单1、《解忧杂货店》2、《摆渡人》","tags":[{"name":"读书","slug":"读书","permalink":"http://willxue.top/tags/读书/"}]},{"title":"Hello World","date":"2017-02-25T06:04:16.745Z","path":"2017/02/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"遗书-2017.02.25","date":"2017-02-25T02:35:12.000Z","path":"2017/02/25/遗书-2017-02-25/","text":"第一封遗书以后每年，我都要写一封遗书。 起因过年的时候，听说孔伟的妈妈得了肝癌 今天早上，刚听丽姐说，二舅家的胜利哥车祸，没了。 人的生命真的脆弱能活到寿终正寝，那是极大的幸运，真是说什么时候没，就什么时候没了。 生命中，那些你争我抢的，那些对我重要的利益，那些我们追求的成功，那么我们想要得到的尊重，婚姻中那些争吵，生命中那么重要的决定，比起生命来，都变成了鸡毛算皮的小事。 有些难过，有些伤心，有些挫折，有些决定，回头想想，有时候，也没想像中那么的“重”，过两年回头再看看，貌似也是风淡云轻。 也许生命这个过程，就是不断的认识自己有多幼稚、傻x的过程。 幸好，我们可以不断的进步。 幸好，我们还可以享受生活的点点滴滴。 珍惜前两天脸上脸上起痘痘，就在嘴边，虽然后来下去了，可破了的伤口还没有完全好就去游泳了，结果造成了感染，吃东西都不敢张大嘴，笑也不敢，也没再去游泳，一周开车10个小时，真真是很累的。游泳的确管用，我的鼠标手也没有那么难受了，腰也没以前那么不舒服了。就因为感染这事儿，耽误了2个星期。 人呢，首先要珍惜自己，自己的身体好了，才能让自己健康，快乐，继而才能照看好自己的家人和身边的朋友。 记得很久以前，看过一部电影，有个人说过这么一段话： 人生不像是在画圆，最中间的圆心是自己；离自己最近的是我们的家人、亲戚；再外一圈是同学，朋友，然后是相识的人，却不怎么熟悉的；最后是社会上的陌生人。 一个人的能力越大，他能画的圆圈就越大，他能帮助和照顾的人就越多。 不过，话说回来，我觉得有时候对老婆、对爸妈还是很不错的. :-) 一转眼，结婚快2年了，现在看看，还不错。 很多时候，感觉老婆还是蛮可爱的，就像带了一个小孩子。哈哈。 回想结婚的头一年，刚开始的时候，也是异地分居，回来我来杭州后，也是小吵不断，让娘子也是流了不少眼泪，稍有愧疚。 以前老婆来月经的时候，情绪就很不稳定；以前自己不舒服的时候，就容易向我发脾气；以前遇到不开的事，也容易耍小性子； 而现在呢？ 娘子竟然喜欢上了读书，当然，那是在我的影响下。:) 娘子现在遇到问题，也能越来越看得开了，想的宽了，脾气性格也越来越温和了，笑的也比前多了。 不得不说，这可以我的功劳。 不过有一点不能不说，也是我们在生活中常说的，时候感觉她在吸收我身上的正能量，而我却变的越来越懒了，这个如何是好…… 每周去一趟超市，周末的时候，我们一起在床上读读书，弄弄自己的blog，一起看个电影，睡个满满的下午觉，晚上一起弄两个小菜，榨个橙汁，都是极好的事情。 不管怎么说，生活还是很美好的。感谢娘子的陪伴！ 关于死亡的认识一直觉得，其实死亡，对于真正死亡的人来说，在某种程度上是一种解脱。 也许我从没有面对过它，但我觉得，死亡也就无知无觉了，也没有烦恼。也许无法再去追求成功、幸福之类的东西或人，但死亡了，也就没有了欲望，有的，是一些生前的遗憾。死亡后，也一切归零。如果是一个有宗教信仰的人，那么死亡后，他们还可以去向他们的神国，那么对于他们来说，也是件幸福的事儿吧。 所以，一直觉得死亡对于逝去的人来说，是一种解脱。但对于亡者身边的人来说，留下的是无尽的痛苦和思念。 遗嘱既然是遗书，那么自然要写点，如果有一天我真的离去了的，要交待的后事。 对母亲其实我最担心的就是妈妈，因为她有心脏病，椎间盘突出，风湿，各种病，人又老了，如果没有人照看，或者爸爸照顾不过来，也很是担心； 前2年理财的钱全赔进去，不知道她有没有足够养老的钱。 如果知道我去了，她能不能接受这个打击，能不能挺得过来。 还没来得急给她生个孙子呢，如果现在就走了，的确是个很大的遗憾。 如果老了，是请佣人照顾吗？到时候该怎么办呢？想想就是件难过的事。 如果有一天我去了，如果能给她带些话的话，就这样对她说： 谢谢妈妈把我养大，把最好的都留给了我，这辈子您辛苦了。 有时候，真的觉得您这一辈子太辛苦了，什么都是省吃俭用，即使是有钱，也舍不得花，舍不得穿，舍不得用。把最好的都留给儿子，用各种方法去赚钱、理财，增加家庭的稳定性。 妈妈是一个居安思危的人 知道你也很是固执，很多事儿想不开，多少人开导你也没用，但想想逝去的生命，其实也没什么东西是放不下的，也没什么东西是想不开的。 让自己快乐一点，比如吃的好一点，去做个按摩，别为了鸡毛蒜皮的事儿，和爸爸吵架，那么生气，万一因为生气而吃药，多不值得。 从我上大学开始，就不在家里了，除了考研那一年，在家里呆了一整年，您把我喂胖了30斤后，其它时间，我都在外地，不是上本科、研究生，就是工作，一直在外面，没能好好的赔你，感觉到遗憾。 记得上大学的研究生的时候，刚刚工作后，那时候每个月或两个月回家一次，每次回家，都找您谈心，说一些工作上的心得，给你说一些怎么才能不生气，怎么想得开一些。其实，我是知道的，你根本就没有听进去，只是陪着儿子聊聊天，更确切的说，只是想听着儿子说说话罢了。 这些年，都没能好好的陪陪你，有时候，感觉很难过。俗说话，“父母在，不远游，游必有方”，我也不知道我是否是“有方”，杭州这边的确在环境和机遇方面比济南要好得多。希望有一天，能在本溪风情买个别墅，接你过来，颐养天年。 对爸爸觉得对爸爸是最不用担心的人，我觉得我的性格和爸爸最像，什么都能看得开一些，再大的苦难，也都能过得去。是个心大，淡然的人。 不过也还是有担心的地方的，不知道是人老了会固执，还是我和爸爸一样，有些事就是很固执的类型，感觉现在他老人家，越来越喜欢听劝了。尤其是在炒股这件事上，感觉爸爸真的不适合去炒股。 如果有一天我去了，如果能给他带些话的话，就这样对他说： 爸，我在“天国”过得很好，没什么可担心的，要好好照顾好自己和妈妈，股票就不要去炒了，好不好？ 如果一定要炒股，那买定一或两支股票，3年内不准买卖，可不可以？ 经常开导一下妈妈，别那么多想不开的事儿，多买点好吃的，想吃什么就吃什么。 对于爸爸，我总的来说，还是很放心的。我觉得性格方面和你最像，所以，您的人生是很成功了，你看，你教出来这么优秀的儿子，哈哈。 对老婆觉得对老婆是第二担心的人，不过我相信你能挺过来的。老婆在变得越来越优秀，脾气变得越来越好，心也变得越来越大，性格变得越来越可能，当然，也越来越漂亮。 知书达礼，这个词用在老婆身上最贴切不过，从老婆喜欢读书开始，变得越来越好了。 如果有一天我去了，如果能给老婆带些话的话，这样对娘子说： 不要让以前的事困住自己，无论是你小时候的事儿，还是我们经历的坎坷，还是我的死亡这件事儿，希望你能战胜他们，做个积极、快乐的人。 这这一生也没什么遗憾，人生能活到35岁也不错了，虽然还没有登上人生的顶峰，也半山腰还是有的，该经历的也都经历的，虽然没什么大风大浪，没什么多大的成就，但有时候觉得，也还算满意啦。从好的方面说，我也不需要再去经历老年时的体弱，再也无需经历病痛，以及各种烦恼，这这个角度来说，我也是幸运的，不是吗？ 亲爱的。 记得上高中的时候，尤其是高二开始，学习特别不好，我觉得那是我人生中最黑暗和无助的时刻，就是那种无论怎么学习，学习成功都没有提升的那种。你有没有那种感觉呢？无论你怎么努力，都得不到你想来的。上高中时，成绩是倒数，我也一样考上了研究生嘛，虽然从来没有学习特别好过，但多努力一下，努力的时候长一点，给生命一点耐心和时间，总会得到你想要的，这是我的总结和经验。之所以，你觉得你无论怎么努力，也没有丝毫的进步。一来，那是因为你努力的还不够，时间不足够的久；二来，找找学习方法，你只是没有找到适合你的学习方法，或者解决问题的方法而已；三来，推及到事业或其它事上，如果你有一个梦想，其实也可以不妨先放下一段时间，散散心，再出发，不要太钻牛角尖，生活会慢慢好起来的。四来，如果实在不行，放弃也不是不行的，有舍才有得嘛，但不要遇到什么事情，都轻易的放弃。 记得我跟你说过吗？ 记得有一个明星的儿子问妈妈，“什么是婚姻”，明星拿过他的ipad，把里面所有的音乐都删除掉，只留下一首歌，对儿子说，“婚姻，就像这ipad的仅剩下的一首歌，你只能单曲循环”。 这话听起来是有点小悲观，人不同于歌，人是会变的，我们都会变得越来越好。我想对老婆说的是，“你这首歌很好听，越循环越好听” 谢谢你给我带来的一切！ 生命中有你，让我觉得不再孤独。谢谢你对我的忍让，谢谢你对我的关心，谢谢你为我流下的所有的眼泪，谢谢你为我做出的所有的改变，谢谢你的善良和美丽。 如果我有一天真的离去，如果有一天你能再次遇到那个Mr.right，就嫁了吧，一个女人自己生活会是很辛苦，希望你能快乐和幸福。如果能得到快乐和幸福，那么一切都可以去尝试哦。我会祝福你的。 遗产好吧，哥哥还是有遗产的，虽然买房子都是爸爸妈妈出的钱。 关于济南的房子，现在价值在170W左右，减去30W（已还款5W左右了吧），还剩下140W，其中100W给我的亲生父母，因为他们老了，也没有什么赚钱能力了，需要足够的钱来养老。40W给老婆，再加上我们的存款、公积金，对了，还有公司给买的商业保险，算上这些，留给老婆的钱，也应该近70W了，这些基本上是平均分配了，稍微侧重爸妈，一来买房子是爸妈出的钱，二来他们没有了赚钱能力，需要钱来养老，三来，现在老婆的赚钱能力还是很强的，老婆还年青。 虽然我才结婚2年，希望爸妈能理解这种分配方式，毕竟官已经35岁了，再嫁人也没以前那么顺畅了。老婆用这近70万，再贷点款，即使在杭州也能买个小房子了，如果回济南，也能买个100来平的房子吧。 最后记得看《哈佛幸福课》上面说，一个人无论遇到多大的悲伤的事儿，比如车祸推卸失掉胳膊或腿，想要自杀；一个人无论遇到多快乐的事儿，比如中了百万或千万大奖，6个月后，他们的心情都会恢复平静，回到他们之前正常的生活水平上去。 所以，我爱的人们，和爱我的人们，一定要挺过6个月哦，6个月后，就没有那么痛了，就会有新的生活等着你们，一定要开心、幸福的生活下去哦。我会在天上祝福你们的。 – 2017年2月25日","tags":[{"name":"遗嘱","slug":"遗嘱","permalink":"http://willxue.top/tags/遗嘱/"}]},{"title":"trycatch包裹要做显式回","date":"2017-02-04T09:46:14.000Z","path":"2017/02/04/trycatch包裹要做显式回/","text":"##trycatch包裹 不会产生异常,无法回滚事务, 要做显式回滚。或者你将捕获的方法继续抛出也可。 1、引入jar类12import org.springframework.transaction.annotation.Transactional;import org.springframework.transaction.interceptor.TransactionAspectSupport; 2、在要使用的方法上面加上1@Transactional 3、在catch中加入1TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.transaction.interceptor.TransactionAspectSupport;@Service(\"testService\")public class testServiceImpl implements testService &#123; @Autowired private Amapper amapper; @Autowired private Bmapper bmapper; @Transactional public Result&lt;testDTO&gt; insertTest(insertTestParam param) &#123; try &#123; .... amapper.insert(A) bmapper.insert(B) .... if (operate &gt; 0) &#123; return Result.create(true, ResultCode.RETURN_SUCC, dto); &#125; return Result.create(false, ResultCode.INSERT_ERROR); &#125; catch (BizException e) &#123; logger.error(e.getMessage()); TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); return Result.create(false, ResultCode.SYSTEM_ERROR, e.getMessage(), null); &#125; catch (Exception e) &#123; logger.error(\"testServiceImpl.insertTest exception,param=&#123;&#125;\", new Object[]&#123;JSON.toJSONString(param)&#125;, e); TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); return Result.create(false, ResultCode.SYSTEM_ERROR, e.getMessage(), null); &#125; &#125;&#125;","tags":[]},{"title":"2017年春节","date":"2017-01-29T13:59:30.000Z","path":"2017/01/29/2017年春节/","text":"感觉过了33岁之后，最缺少的是时间。 要做的事，想做的事，有很多很多。 过个年，本来想着有13天的假期，可以看完一本书呢。结果回来之后，连书都没有翻开过。 在济南，白天睡醒了，就出发，晚上10点半才回来，洗洗就又睡了，感觉每天都在路上了。 如果一个月都读不完一本书，岂不是奶郁闷？！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://willxue.top/tags/随笔/"}]},{"title":"日交易额百亿级交易系统的超轻量日志实现","date":"2017-01-28T15:14:32.000Z","path":"2017/01/28/日交易额百亿级交易系统的超轻量日志实现/","text":"日交易额百亿级交易系统的超轻量日志实现 基于双缓冲队列、多刷盘机制的超轻量级 java 日志 原文: yfonly Features 双缓冲队列 多种刷盘机制，支持时间触发、缓存大小触发、服务关闭强制触发等刷盘方式 多种RollingFile机制，支持文件大小触发、按天触发等Rolling方式 多日志级别，支持debug、info、warn、error和fatal等日志级别 热加载，由日志事件触发热加载 超轻量，不依赖任何第三方库 性能保证，成功用于日交易额百亿级交易系统 Usage1. Maven12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.cyfonly&lt;/groupId&gt; &lt;artifactId&gt;flogger&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;``` #### 2. flogger.properties see `Config` #### 3. In your project code //获取单例FLogger logger = FLogger.getInstance();//简便api,只需指定内容logger.info(“Here is your message…”);//指定日志级别和内容，文件名自动映射logger.writeLog(Constant.WARN, “Here is your customized level message…”);//指定日志输出文件名、日志级别和内容logger.writeLog(“error”, Constant.ERROR, “Here is your customized log file and level message…”);123# Output #### info.log [INFO] 2016-12-06 21:07:32:840 [main] Here is your message…1#### warn.log [WARN] 2016-12-06 21:07:32:842 [main] Here is your customized level message…1#### error.log [ERROR] 2016-12-06 21:07:32:842 [main] Here is your customized log file and level message…1234567891011# Config #### 1. 配置文件名称 flogger.properties #### 2. 配置文件加载顺序 1. 项目根路径2. src/main/resources3. 默认配置 #### 3. 配置项 ########## 公共环境配置 ########## 字符集CHARSET_NAME = UTF-8 ########## 日志信息配置 ########## 日志级别 0:调试信息 1:普通信息 2:警告信息 3:错误信息 4:严重错误信息LOG_LEVEL = 0,1,2,3,4 日志文件存放路径LOG_PATH =./log 日志写入文件的间隔时间(默认为1000毫秒)WRITE_LOG_INV_TIME = 1000 单个日志文件的大小(默认为10M)SINGLE_LOG_FILE_SIZE = 10485760 单个日志文件缓存的大小(默认为10KB)SINGLE_LOG_CACHE_SIZE = 10240123456789101112131415161718192021222324252627282930313233343536373839404142## 源码解析上面这么多都是围绕如何使用进行说明，下面就针对 FLogger 的特性进行实现逻辑的源码解析。## 双缓冲队列FLogger 在内部采用双缓冲队列，那何为双缓冲队列呢？它的作用又是什么呢？FLogger 为每个日志文件维护了一个内部对象 LogFileItem ，定义如下：```javapublic class LogFileItem &#123; /** 不包括路径，不带扩展名的日志文件名称 如：MsgInner */ public String logFileName = \"\"; /** 包括路径的完整日志名称 */ public String fullLogFileName = \"\"; /** 当前日志文件大小 */ public long currLogSize = 0; /** 当前正在使用的日志缓存 */ public char currLogBuff = 'A'; /** 日志缓冲列表A */ public ArrayList&lt;StringBuffer&gt; alLogBufA = new ArrayList&lt;StringBuffer&gt;(); /** 日志缓冲列表B */ public ArrayList&lt;StringBuffer&gt; alLogBufB = new ArrayList&lt;StringBuffer&gt;(); /** 下次日志输出到文件时间 */ public long nextWriteTime = 0 ; /** 上次写入时的日期 */ public String lastPCDate = \"\"; /** 当前已缓存大小 */ public long currCacheSize = 0;&#125; 在每次写日志时，日志内容作为一个 StringBuffer 添加到当前正在使用的 ArrayList 中，另一个则空闲。当内存中的日志输出到磁盘文件时，会将当前使用的 ArrayList 与空闲的 ArrayList 进行角色交换，交换后之前空闲的 ArrayList 将接收日志内容，而之前拥有日志内容的 ArrayList 则用来输出日志到磁盘文件。这样就可以避免每次刷盘时影响日志内容的接收（即所谓的 stop-the-world 效应）及多线程问题。流程如下： 关键代码如下： 日志接收代码 123456789/同步单个文件的日志synchronized(lfi)&#123; if(lfi.currLogBuff == 'A')&#123; lfi.alLogBufA.add(logMsg); &#125;else&#123; lfi.alLogBufB.add(logMsg); &#125; lfi.currCacheSize += CommUtil.StringToBytes(logMsg.toString()).length;&#125; 日志刷盘代码： 1234567891011121314151617//获得需要进行输出的缓存列表ArrayList&lt;StringBuffer&gt; alWrtLog = null;synchronized(lfi)&#123; if(lfi.currLogBuff == 'A')&#123; alWrtLog = lfi.alLogBufA; lfi.currLogBuff = 'B'; &#125;else&#123; alWrtLog = lfi.alLogBufB; lfi.currLogBuff = 'A'; &#125; lfi.currCacheSize = 0;&#125;//创建日志文件createLogFile(lfi);//输出日志int iWriteSize = writeToFile(lfi.fullLogFileName,alWrtLog);lfi.currLogSize += iWriteSize; 多刷盘机制FLogger 支持多种刷盘机制： 刷盘时间间隔触发 内存缓冲大小触发 退出强制触发 下面就来一一分析。刷盘时间间隔触发 配置项如下： 日志写入文件的间隔时间(默认为1000毫秒) WRITE_LOG_INV_TIME = 1000 单个日志文件缓存的大小(默认为10KB)SINGLE_LOG_CACHE_SIZE = 10240 单个日志文件缓存的大小(默认为10KB) SINGLE_LOG_CACHE_SIZE = 10240 当内存缓冲队列的大小超过配置大小时，将执行内存日志刷盘。退出强制触发 FLogger 内部注册了 JVM 关闭钩子 ShutdownHook ，当 JVM 正常关闭时，由钩子触发强制刷盘，避免内存日志丢失。相关代码如下：12345678public FLogger()&#123; Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123; @Override public void run() &#123; close(); &#125; &#125;));&#125; public FLogger(){ Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() { @Override public void run() { close(); } }));} 当 JVM 异常退出时无法保证内存中的日志全部落盘，但可以通过一种妥协的方式来提高日志刷盘的实时度：设置 SINGLE_LOG_CACHE_SIZE = 0 或者 WRITE_LOG_INV_TIME = 0 。 刷盘代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** 线程方法 */public void run()&#123; int i = 0 ; while(bIsRun)&#123; try&#123; //输出到文件 flush(false); //重新获取日志级别 if(i++ % 100 == 0)&#123; Constant.CFG_LOG_LEVEL = CommUtil.getConfigByString(\"LOG_LEVEL\",\"0,1,2,3,4\"); i = 1; &#125; &#125;catch(Exception e)&#123; System.out.println(\"开启日志服务错误...\"); e.printStackTrace(); &#125; &#125;&#125;/** 关闭方法 */public void close()&#123; bIsRun = false; try&#123; flush(true); &#125;catch(Exception e)&#123; System.out.println(\"关闭日志服务错误...\"); e.printStackTrace(); &#125;&#125;/*** 输出缓存的日志到文件* @param bIsForce 是否强制将缓存中的日志输出到文件*/private void flush(boolean bIsForce) throws IOException&#123; long currTime = System.currentTimeMillis(); Iterator&lt;String&gt; iter = logFileMap.keySet().iterator(); while(iter.hasNext())&#123; LogFileItem lfi = logFileMap.get(iter.next()); if(currTime &gt;= lfi.nextWriteTime || SINGLE_LOG_CACHE_SIZE &lt;= lfi.currCacheSize || bIsForce == true)&#123; //获得需要进行输出的缓存列表 ArrayList&lt;StringBuffer&gt; alWrtLog = null; synchronized(lfi)&#123; if(lfi.currLogBuff == 'A')&#123; alWrtLog = lfi.alLogBufA; lfi.currLogBuff = 'B'; &#125;else&#123; alWrtLog = lfi.alLogBufB; lfi.currLogBuff = 'A'; &#125; lfi.currCacheSize = 0; &#125; //创建日志文件 createLogFile(lfi); //输出日志 int iWriteSize = writeToFile(lfi.fullLogFileName,alWrtLog); lfi.currLogSize += iWriteSize; &#125; &#125; &#125; 多 RollingFile 机制同 log4j/logback，FLogger 也支持多种 RollingFile 机制： 按文件大小 Rolling 按天 Rolling 其中按文件大小 Rolling，配置项为： 单个日志文件的大小(默认为10M)SINGLE_LOG_FILE_SIZE = 10485760 即当文件大小超过配置大小时，将创建新的文件记录日志，同时重命名旧文件为”日志文件名日期时间.log”（如 info_20161208_011105.log）。 按天 Rolling 即每天产生不同的文件。 产生的日志文件列表可参考如下： info_20161207_101105.log info_20161207_122010.log info_20161208_011110.log info_20161208_015010.log info.log 当前正在写入的日志文件为 info.log。 关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/*** 创建日志文件* @param lfi*/private void createLogFile(LogFileItem lfi)&#123; //当前系统日期 String currPCDate = TimeUtil.getPCDate('-'); //如果超过单个文件大小，则拆分文件 if(lfi.fullLogFileName != null &amp;&amp; lfi.fullLogFileName.length() &gt; 0 &amp;&amp; lfi.currLogSize &gt;= LogManager.SINGLE_LOG_FILE_SIZE )&#123; File oldFile = new File(lfi.fullLogFileName); if(oldFile.exists())&#123; String newFileName = Constant.CFG_LOG_PATH + \"/\" + lfi.lastPCDate + \"/\" + lfi.logFileName + \"_\" + TimeUtil.getPCDate() + \"_\"+ TimeUtil.getCurrTime() + \".log\"; File newFile = new File(newFileName); boolean flag = oldFile.renameTo(newFile); System.out.println(\"日志已自动备份为 \" + newFile.getName() + ( flag ? \"成功!\" : \"失败!\" ) ); lfi.fullLogFileName = \"\"; lfi.currLogSize = 0; &#125; &#125; //创建文件 if ( lfi.fullLogFileName == null || lfi.fullLogFileName.length() &lt;= 0 || lfi.lastPCDate.equals(currPCDate) == false )&#123; String sDir = Constant.CFG_LOG_PATH + \"/\" + currPCDate ; File file = new File(sDir); if(file.exists() == false)&#123; file.mkdir(); &#125; lfi.fullLogFileName = sDir + \"/\" + lfi.logFileName + \".log\"; lfi.lastPCDate = currPCDate; file = new File(lfi.fullLogFileName); if(file.exists())&#123; lfi.currLogSize = file.length(); &#125;else&#123; lfi.currLogSize = 0; &#125; &#125;&#125; 多日志级别FLogger 支持多种日志级别：DEBUG INFO WARN ERROR FATAL FLogger 为每个日志级别都提供了简易 API，在此就不再赘述了。 Demosee https://github.com/cyfonly/FLogger/tree/master/src/test License基于 Apache License 2.0 发布。有关详细信息，请参阅 LICENSE。 转自：yfonlyhttp://www.importnew.com/23206.html","tags":[{"name":"日志","slug":"日志","permalink":"http://willxue.top/tags/日志/"}]},{"title":"风之街","date":"2017-01-14T03:51:26.000Z","path":"2017/01/14/风之街/","text":"翼年代记－风の街へ风の街へ的罗马音和中文歌词时の向こう 风の街へ ねえ、连れて行って白い花の梦かなえて在时空的对面 向着风之街带着我过去实现纯白色花儿的梦想 甘い指でこの手を取りねえ、远い道を导いて欲しいの あなたの侧へ 用稚嫩的手指牵起这双手愿引领着我步向遥远的你的身边 その歌声変えない昼下がり目覚めて二人は一つになり幸せの意味を初めて知るのでしょう 连れて行って…… 那个歌声直到夕阳西下也未能停息睁眼醒来 两人已合二为一这才第一次明白幸福的含义带着我过去…… この歌声切なく高らかに 全ての心に响きのでしょう幸せの意味を知らずに眠る夜に……是这个痛苦却宏亮的歌声才响彻所有人的心中对幸福的含义一无所知的安眠之夜…… 未だ知らない梦の向こうねえ、远い道を二人で行けるわ 风の街へ 在未知之梦的对面两人向遥远的风之街而去 toki no mukou kaze no machi henee tsurete itteshiroi hana no yume kanaete amaiyubi de konote wo torinee tooimichi womichibiite hoshii noanata no soba he sono utakoe kaenai hirusagarimezamete futari ha hitotsu ni narishiawase no imi wo hajimete shirunodeshoutsurete itte kono utakoe setsunaku takarakanisubete no kokoro ni hibikinodeshoushiawase no imi wo shirazuni nemuru yoru ni madashiranai yume no mukounee tooi michi wofutari de yukeruwakaze no machi he 下载链接：http://pan.baidu.com/s/1hshwb0C","tags":[]},{"title":"forest","date":"2017-01-14T03:41:28.000Z","path":"2017/01/14/forest/","text":"最近老婆喜欢听日语歌，然后翻看自己曾经的那些下载，回想一些当年超喜欢的歌。你祝愿老婆早日能学会一首日语歌。;-) 不得不说，梶浦由记 还是很逼的。 以下附歌词和下载链接 forest（森林）summer rain falls on the apple branches夏日细雨，落在苹果树枝头lights from heaven dancing with the shadows天堂的光芒与暗影相伴舞蹈 come take my hand牵起我的手吧let me be in your forest让我步入你的森林 sometimes you think loneliness is better than pain有时你认为孤独好过痛苦and you think deeper in your valley因此你能够更深入地思考 is this the place to be, in your memory?我是否能从这里进入你的记忆？no,I never wanna lose you in the forest of the night不，我从没想过将你遗弃在这夜晚的森林 in vanlity’s lair让你在幻觉的巢穴中yearning for the angel calling渴求着天使的呼唤hear the lonely prayer ringing through the land of rain听着那孤独的祷告回响在被雨水侵蚀的大陆across the thin air穿过稀薄的空气the sing voice to voice它们传唱着这旋律the ancient melodies这古老的记忆calling you呼唤着你 autumn goes by秋天走过combing twilight into my hair将暮光梳进我的发丝I look back on the passing tenderness我转过头，回望那自身旁经过的温柔 let me stay by your side让我陪伴你In your memory留在你的回忆中 no,you never gonna find me in the forest of the night不，你从没打算到夜晚的森林中寻找我in vanlity’s lair在幻觉的巢穴中no more holly angel calling不再有圣洁的天使的呼唤hear my lonely prayer ringing through the land of rain听着我孤独的祷告回响在被雨水侵蚀的大陆across the thin air穿过稀薄的空气we sing voice to voice我们传唱着这旋律the ancient melodies这古老的记忆I’m calling you我在呼唤着你 no,you never gonna find me in the forest of the night不，你从没打算到夜晚的森林中寻找我in vanlity’s lair在幻觉的巢穴中no more holly angel calling不再有圣洁的天使的呼唤hear my lonely prayer ringing through the land of rain听着我孤独的祷告回响在被雨水侵蚀的大陆across the thin air穿过稀薄的空气we sing voice to voice我们传唱着这旋律the ancient melodies这古老的记忆melodies满满的回忆calling you呼唤着你 链接：http://pan.baidu.com/s/1jImbHeI 密码：d80g","tags":[]},{"title":"高并发下的日期格式化问题","date":"2017-01-14T03:13:43.000Z","path":"2017/01/14/高并发下的日期格式化问题/","text":"1、问题一个common包中，有这样的一个工具类，代码如下。（备注：LZ为了简单，去掉了很多跟本文无关的代码，但不影响阅读，因为这个类就是一些静态的工具类方法，主要用于处理日期）1234567891011public class DateUtil &#123; private DateUtil()&#123;&#125; private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static Date parse(String date) throws ParseException &#123; return DATE_FORMAT.parse(date); &#125; &#125; 这个类特别简单，相信有不少猿友都会觉得这个类没有多大问题。因为这段代码太简单了，当你的项目报错的时候，你很难想到这段代码就是错误的根源。 大致描述一下这个工具类使用的场景。LZ的hbase应用接收了来自于其它系统大量的日志信息，并会将这些日志信息存储在hbase当中，其实就是一个简单的日志保存功能。如果单纯从功能上来讲，就是一个简单的curd（增删改查）操作中的c（增）操作。唯一不同的是，由于存储的是来自很多系统的系统日志,webservice日志,mq日志,url访问日志，因此并发量会有点高，至少比LZ平时做的企业应用要高太多太多了。 这个工具类就是在解析日志信息中的日期字符串（比如日志的发生时间）时报的错，具体的错误信息如下。（备注：以下是真实的报错信息，显示的错误位置与上面的代码不符，不过各位猿友完全可以认为就是上面的方法报的错，因为事实上parseTimestamp这个方法就和上面方法的代码是一样的。）12345678910111213java.lang.NumberFormatException: For input string: \"\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48) at java.lang.Long.parseLong(Long.java:431) at java.lang.Long.parseLong(Long.java:468) at java.text.DigitList.getLong(DigitList.java:177) at java.text.DecimalFormat.parse(DecimalFormat.java:1297) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1589) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1311) at java.text.DateFormat.parse(DateFormat.java:335) at com.xxxxxxx.core.common.util.DateUtil.parseTimestamp(DateUtil.java:95) at com.xxxxxxx.core.common.util.DateUtil.parse(DateUtil.java:84) at com.xxxxxxx.hbase.generator.LogRowKeyGenerator.generate(LogRowKeyGenerator.java:21) ... 22 more 2、问题分析看到这个错误，大部分老道一点的程序猿一眼就能定位问题，肯定是传过来的日期格式不对，所以导致在解析的时候出错了。 LZ自认为还算老道吧（小小的自夸一下），自然也很快的意识到了问题的根源。于是最简单的方式，调试一下代码，看传过来的日志信息到底是什么样子。 LZ在catch块里加入了断点，当报出这个错误的时候，会进入调试（只能在catch块里捕捉，因为这个异常是时而出现的，而且毫无规律）。但是结果很意外，LZ仔细且认真的看了传送过来的日志信息，日期格式却明明是正确的。这时候LZ就傻眼了，格式明明是正确的，解析怎么可能报错呢？ LZ不相信这种奇怪的问题，于是LZ采用最简单的办法，希望印证心中所想，将代码改成如下的样子。 123456789101112public class DateUtil &#123; private DateUtil()&#123;&#125; private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static Date parse(String date) throws ParseException &#123; System.out.println(\"date:\" + date); return DATE_FORMAT.parse(date); &#125; &#125; 这是最简单粗暴的调试方式，也是LZ初入程序猿这个职业时经常用的办法。可惜，结果依然不如人意，当偶尔出现异常时，打印出来的日志格式依旧是正确的。事实上，各个系统使用的客户端也是LZ开发的，也不应该出现日期格式错误的问题。 这到底怎么回事呢？事实就是，日期格式是正确的，但就是解析失败！ 解决方案打开了SimpleDateFormat这个类的源码。果然，在这个类的注释里，有这么一段话。 Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally. 这段话的意思很简单，翻译过来就是：日期格式化的类是非同步的，建议为每一个线程创建独立的格式化实例。如果多个线程并发访问同一个格式化实例，就必须在外部添加同步机制。 由于LZ错误的将SimpleDateFormat的单个实例放置于高并发的环境下，并且没有任何同步机制，于是就导致了这个奇葩的问题。接下来，LZ便快速的将代码改成了类似于如下的形式。123456789public class DateUtil &#123; private DateUtil()&#123;&#125; public static Date parse(String date) throws ParseException &#123; return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(date); &#125; &#125; 果然，那个奇怪的异常再也不出现了，事情到此已经水落石出了。最后，LZ奉上一段示例代码，猿友们运行这个程序，就会出现解析失败的异常，但是很明显，我们的日期格式是正确的。1234567891011121314151617181920212223242526272829303132import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class DateUtil &#123; private DateUtil()&#123;&#125; private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(500); for (int i = 0; i &lt; 500; i++) &#123; executorService.execute(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; try &#123; DATE_FORMAT.parse(\"2014-01-01 00:00:00\"); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; Thread.sleep(3000000); &#125;&#125; 转自：左潇龙","tags":[{"name":"高并发，日期格式化","slug":"高并发，日期格式化","permalink":"http://willxue.top/tags/高并发，日期格式化/"}]},{"title":"端口被占用","date":"2017-01-12T03:54:05.000Z","path":"2017/01/12/port_is_occupied/","text":"1、cmd进入命令行：1099为被占用的端口1netstat -aon|findstr 1099 2、找到被占用的端口，kill掉就好了。1taskkill -f -pid 2748","tags":[{"name":"端口被占用","slug":"端口被占用","permalink":"http://willxue.top/tags/端口被占用/"}]},{"title":"lambda表达式","date":"2017-01-09T14:28:15.000Z","path":"2017/01/09/lambda表达式/","text":"lambda表达式学习笔记","tags":[]},{"title":"排序算法","date":"2017-01-07T16:19:36.000Z","path":"2017/01/08/排序算法/","text":"经典排序算法github文件链接https://github.com/wuchong/Algorithm-Interview","tags":[{"name":"算法","slug":"算法","permalink":"http://willxue.top/tags/算法/"}]},{"title":"51talk-note","date":"2017-01-07T12:29:34.000Z","path":"2017/01/07/51talk-note/","text":"hair cap头发帽 goggles泳镜 rashguard防晒泳衣 respiratory system scoldvi. 责骂；叱责vt. 骂；责骂 cause of actionAs a course of action, the group of survivors need try to get to the top of the building to avoid the undead. shaddock柚子","tags":[]},{"title":"photo_test","date":"2017-01-01T04:46:14.000Z","path":"2017/01/01/photo-test/","text":"图片测试","tags":[]},{"title":"ReentrantLock实现原理深入探究","date":"2016-12-29T13:51:47.000Z","path":"2016/12/29/ReentrantLock实现原理深入探究/","text":"ReentrantLock实现原理深入探究前言这篇文章被归到Java基础分类中，其实真的一点都不基础。网上写ReentrantLock的使用、ReentrantLock和synchronized的区别的文章很多，研究ReentrantLock并且能讲清楚ReentrantLock的原理的文章很少，本文就来研究一下ReentrantLock的实现原理。研究ReentrantLock的实现原理需要比较好的Java基础以及阅读代码的能力，有些朋友看不懂没关系，可以以后看，相信你一定会有所收获。 最后说一句，ReentrantLock是基于AQS实现的，这在下面会讲到，AQS的基础又是CAS，如果不是很熟悉CAS的朋友，可以看一下这篇文章Unsafe与CAS。 AbstractQueuedSynchronizerReentrantLock实现的前提就是AbstractQueuedSynchronizer，简称AQS，是java.util.concurrent的核心，CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类。先用两张表格介绍一下AQS。第一个讲的是Node，由于AQS是基于FIFO队列的实现，因此必然存在一个个节点，Node就是一个节点，Node里面有： 属 性 定 义 Node SHARED = new Node() 表示Node处于共享模式 Node EXCLUSIVE = null 表示Node处于独占模式 int CANCELLED = 1 因为超时或者中断，Node被设置为取消状态，被取消的Node不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态，处于这种状态的Node会被踢出队列，被GC回收 int SIGNAL = -1 表示这个Node的继任Node被阻塞了，到时需要通知它 int CONDITION = -2 表示这个Node在条件队列中，因为等待某个条件而被阻塞 int PROPAGATE = -3 使用在共享模式头Node有可能处于这种状态， 表示锁的下一次获取可以无条件传播 int waitStatus 0，新Node会处于这种状态 Node prev 队列中某个Node的前驱Node Node next 队列中某个Node的后继Node Thread thread 这个Node持有的线程，表示等待锁的线程 Node nextWaiter 表示下一个等待condition的Node 看完了Node，下面再看一下AQS中有哪些变量和方法： 属性/方法 含 义 Thread exclusiveOwnerThread 这个是AQS父类AbstractOwnableSynchronizer的属性，表示独占模式同步器的当前拥有者 Node 上面已经介绍过了，FIFO队列的基本单位 Node head FIFO队列中的头Node Node tail FIFO队列中的尾Node int state 同步状态，0表示未锁 int getState() 获取同步状态 setState(int newState) 设置同步状态 boolean compareAndSetState(int expect, int update) 利用CAS进行State的设置 long spinForTimeoutThreshold = 1000L 线程自旋等待的时间 Node enq(final Node node) 插入一个Node到FIFO队列中 Node addWaiter(Node mode) 为当前线程和指定模式创建并扩充一个等待队列 void setHead(Node node) 设置队列的头Node void unparkSuccessor(Node node) 如果存在的话，唤起Node持有的线程 void doReleaseShared() 共享模式下做释放锁的动作 void cancelAcquire(Node node) 取消正在进行的Node获取锁的尝试 boolean shouldParkAfterFailedAcquire(Node pred, Node node) 在尝试获取锁失败后是否应该禁用当前线程并等待 void selfInterrupt() 中断当前线程本身 boolean parkAndCheckInterrupt() 禁用当前线程进入等待状态并中断线程本身 boolean acquireQueued(final Node node, int arg) 队列中的线程获取锁 tryAcquire(int arg) 尝试获得锁（由AQS的子类实现它） tryRelease(int arg) 尝试释放锁（由AQS的子类实现它） isHeldExclusively() 是否独自持有锁 acquire(int arg) 获取锁 release(int arg) 释放锁 compareAndSetHead(Node update) 利用CAS设置头Node compareAndSetTail(Node expect, Node update) 利用CAS设置尾Node compareAndSetWaitStatus(Node node, int expect, int update) 利用CAS设置某个Node中的等待状态 上面列出了AQS中最主要的一些方法和属性。整个AQS是典型的模板模式的应用，设计得十分精巧，对于FIFO队列的各种操作在AQS中已经实现了，AQS的子类一般只需要重写tryAcquire(int arg)和tryRelease(int arg)两个方法即可。 ReentrantLock的实现ReentrantLock中有一个抽象类Sync：1234567891011private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; ... &#125; ReentrantLock根据传入构造方法的布尔型参数实例化出Sync的实现类FairSync和NonfairSync，分别表示公平的Sync和非公平的Sync。由于ReentrantLock我们用的比较多的是非公平锁，所以看下非公平锁是如何实现的。假设线程1调用了ReentrantLock的lock()方法，那么线程1将会独占锁，整个调用链十分简单： 第一个获取锁的线程就做了两件事情： 1、设置AbstractQueuedSynchronizer的state为1 2、设置AbstractOwnableSynchronizer的thread为当前线程 这两步做完之后就表示线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下必然是行不通的，所以线程2就要阻塞。那么，线程2如何被阻塞？看下线程2的方法调用链，这就比较复杂了： 调用链看到确实非常长，没关系，结合代码分析一下，其实ReentrantLock没有那么复杂，我们一点点来扒代码：123456final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 首先线程2尝试利用CAS去判断state是不是0，是0就设置为1，当然这一步操作肯定是失败的，因为线程1已经将state设置成了1，所以第2行必定是false，因此线程2走第5行的acquire方法： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 从字面上就很好理解这个if的意思，先走第一个判断条件尝试获取一次锁，如果获取的结果为false即失败，走第二个判断条件添加FIFO等待队列。所以先看一下tryAcquire方法做了什么，这个方法最终调用到的是Sync的nonfairTryAcquire方法：123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; 由于state是volatile的，所以state对线程2具有可见性，线程2拿到最新的state，再次判断一下能否持有锁（可能线程1同步代码执行得比较快，这会儿已经释放了锁），不可以就返回false。 注意一下第10~第16行，这段代码的作用是让某个线程可以多次调用同一个ReentrantLock，每调用一次给state+1，由于某个线程已经持有了锁，所以这里不会有竞争，因此不需要利用CAS设置state（相当于一个偏向锁）。从这段代码可以看到，nextc每次加1，当nextc&lt;0的时候抛出error，那么同一个锁最多能重入Integer.MAX_VALUE次，也就是2147483647。 然后就走到if的第二个判断里面了，先走AQS的addWaiter方法：1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 先创建一个当前线程的Node，模式为独占模式（因为传入的mode是一个NULL），再判断一下队列上有没有节点，没有就创建一个队列，因此走enq方法：123456789101112131415161718192021private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize Node h = new Node(); // Dummy header h.next = node; node.prev = h; if (compareAndSetHead(h)) &#123; tail = node; return h; &#125; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 这个方法其实画一张图应该比较好理解，形成一个队列之后应该是这样的： 图片 每一步都用图表示出来了，由于线程2所在的Node是第一个要等待的Node，因此FIFO队列上肯定没有内容，tail为null，走的就是第4行~第10行的代码逻辑。这里用了CAS设置头Node，当然有可能线程2设置头Node的时候CPU切换了，线程3已经把头Node设置好了形成了上图所示的一个队列，这时线程2再循环一次获取tail，由于tail是volatile的，所以对线程2可见，线程2看见tail不为null，就走到了13行的else里面去往尾Node后面添加自身。整个过程下来，形成了一个双向队列。最后走AQS的acquireQueued(node, 1)：12345678910111213141516171819final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (RuntimeException ex) &#123; cancelAcquire(node); throw ex; &#125;&#125; 此时再做判断，由于线程2是双向队列的真正的第一个Node（前面还有一个h），所以第5行~第10行再次判断一下线程2能不能获取锁（可能这段时间内线程1已经执行完了把锁释放了，state从1变为了0），如果还是不行，先调用AQS的shouldParkAfterFailedAcquire(p, node)方法：123456789101112131415161718192021222324252627private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int s = pred.waitStatus; if (s &lt; 0) /* * This node has already set status asking a release * to signal it, so it can safely park */ return true; if (s &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node;&#125; else /* * Indicate that we need a signal, but don't park yet. Caller * will need to retry to make sure it cannot acquire before * parking. */ compareAndSetWaitStatus(pred, 0, Node.SIGNAL); return false;&#125; 吐槽一下先，这段代码的代码格式真糟糕（看来JDK的开发大牛们也有写得不好的地方），这个waitStatus是h的waitStatus，很明显是0，所以此时把h的waitStatus设置为Noed.SIGNAL即-1并返回false。既然返回了false，上面的acquireQueued的11行if自然不成立，再走一次for循环，还是先尝试获取锁，不成功，继续走shouldParkAfterFailedAcquire，此时waitStatus为-1，小于0，走第三行的判断，返回true。然后走acquireQueued的11行if的第二个判断条件parkAndCheckInterrupt： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 123456public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); unsafe.park(false, 0L); setBlocker(t, null);&#125; 最后一步，调用LockSupport的park方法阻塞住了当前的线程。至此，使用ReentrantLock让线程1独占锁、线程2进入FIFO队列并阻塞的完整流程已经整理出来了。 lock()的操作明了之后，就要探究一下unlock()的时候代码又做了什么了，接着看下一部分。 unlock()的时候做了什么就不画流程图了，直接看一下代码流程，比较简单，调用ReentrantLock的unlock方法： 123public void unlock() &#123; sync.release(1);&#125; 走AQS的release：123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 先调用Sync的tryRelease尝试释放锁：123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 首先，只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开。 当一条线程对同一个ReentrantLock全部解锁之后，AQS的state自然就是0了，AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，方法返回true。代码继续往下走，上面的release方法的第四行，h不为null成立，h的waitStatus为-1，不等于0也成立，所以走第5行的unparkSuccessor方法：1234567891011121314151617181920212223private void unparkSuccessor(Node node) &#123; /* * Try to clear status in anticipation of signalling. It is * OK if this fails or if status is changed by waiting thread. */ compareAndSetWaitStatus(node, Node.SIGNAL, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; s即h的下一个Node，这个Node里面的线程就是线程2，由于这个Node不等于null，所以走21行，线程2被unPark了，得以运行。有一个很重要的问题是：锁被解了怎样保证整个FIFO队列减少一个Node呢？这是一个很巧妙的设计，又回到了AQS的acquireQueued方法了：12345678910111213141516171819final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (RuntimeException ex) &#123; cancelAcquire(node); throw ex; &#125;&#125; 被阻塞的线程2是被阻塞在第12行，注意这里并没有return语句，也就是说，阻塞完成线程2依然会进行for循环。 然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束，后面的Node也是一样的原理。 这里有一个细节，看一下setHead方法：12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; setHead方法里面的前驱Node是Null，也没有线程，那么为什么不用一个在等待的线程作为Head Node呢？ 因为一个线程随时有可能因为中断而取消，而取消的话，Node自然就要被GC了，那GC前必然要把头Node的后继Node变为一个新的头而且要应对多种情况，这样就很麻烦。用一个没有thread的Node作为头，相当于起了一个引导作用，因为head没有线程，自然也不会被取消。 再看一下上面unparkSuccessor的14行~20行，就是为了防止head的下一个node被取消的情况，这样，就从尾到头遍历，找出离head最近的一个node，对这个node进行unPark操作。 ReentrantLock其他方法的实现如果能理解ReentrantLock的实现方式，那么你会发现ReentrantLock中其余一些方法的实现还是很简单的，从JDK API关于ReentrantLock方法的介绍这部分，举几个例子： 1、int getHoldCount()123final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0;&#125; 获取ReentrantLock的lock()方法被调用了几次，就是state的当前值 2、Thread getOwner()123final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread();&#125; 获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值 3、Collection getQueuedThreads()123456789public final Collection&lt;Thread&gt; getQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; return list;&#125; 从尾到头遍历一下，添加进ArrayList中 4、int getQueuedLength()12345678public final int getQueueLength() &#123; int n = 0; for (Node p = tail; p != null; p = p.prev) &#123; if (p.thread != null) ++n; &#125; return n;&#125; 从尾到头遍历一下，累加n。当然这个方法和上面那个方法可能是不准确的，因为遍历的时候可能别的线程又往队列尾部添加了Node。 其余方法也都差不多，可以自己去看一下。 遗留问题ReentrantLock的流程基本已经理清楚了，现在还有一个遗留问题：我们知道ReentrantLock是可以指定公平锁或是非公平锁，那么到底是怎么样的代码差别导致公平锁和非公平锁的产生的呢？ 说实话，这个问题，我自己到现在还没有完全想通。之后会持续跟进这个问题，一旦想明白了，会第一时间更新此文或者是新发一篇文章来专门讲述公平ReentrantLock和非公平ReentrantLock在代码上的差别。 原文地址: http://www.importnew.com/22924.htmlhttp://www.cnblogs.com/xrq730/p/4979021.html","tags":[{"name":"多线程","slug":"concurrent","permalink":"http://willxue.top/tags/concurrent/"}]},{"title":"Troubleshooting Long GC Pauses","date":"2016-12-29T02:56:05.000Z","path":"2016/12/29/Troubleshooting-Long-GC-Pauses/","text":"Troubleshooting Long GC Pauses 垃圾收集器长时间停顿By Poonam-Oracle on Jul 31, 2013 Low pause times during the application run is the most important goal for many enterprise applications, especially for the transaction-based systems where long latencies can result in the transaction time-outs. For systems running on the Java Virtual Machines, garbage collections can sometimes be the cause of the long pauses. In this post I am going to describe different scenarios where we can encounter long GC pauses and how we can diagnose and troubleshoot these GC pauses. Causes Following are the different situations that can cause long GC pauses during the application run. 1. Fragmentation in the heapFragmentation in the Java Heap can cause GCs to occur more frequently and also sometimes causing long pauses in the GCs. This is more probable in the case of Concurrent Mark Sweep collector, also known as CMS, where the tenured generation space is not compacted with the concurrent collections. In case of the CMS, due to fragmentation in the tenured generation space, the young generation collections can face promotion failures and thus triggering ‘Concurrent Mode Failure’ collections that are stop-the-world Full GCs, and Full GCs take a long time to finish as compared to the concurrent collection pauses. Due to the fragmentation, the direct allocations in the tenured generation may fail even when there is lot of free space available and thus causing Full GCs. Fragmentation can also cause frequent allocation failures and thus triggering frequent Full GCs that increase the overall time the application is paused for. The following logs collected with the CMS collector show that the fragmentation in the CMS generation space is very high, that leads to the promotion failure during a young generation ParNew collection and then a ‘concurrent mode failure’. A Full GC is done in the event of ‘concurrent mode failure’ that takes a very long time, 17.1365396 seconds to finish.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123;Heap before GC invocations=7430 (full 24):par new generation total 134400K, used 121348K [0x53000000, 0x5c600000, 0x5c600000)eden space 115200K, 99% used [0x53000000, 0x5a07e738, 0x5a080000)from space 19200K, 32% used [0x5a080000, 0x5a682cc0, 0x5b340000)to space 19200K, 0% used [0x5b340000, 0x5b340000, 0x5c600000)concurrent mark-sweep generation total 2099200K, used 1694466K [0x5c600000, 0xdc800000, 0xdc800000)concurrent-mark-sweep perm gen total 409600K, used 186942K [0xdc800000, 0xf5800000, 0xfbc00000)10628.167: [GC Before GC:Statistics for BinaryTreeDictionary:------------------------------------Total Free Space: 103224160Max Chunk Size: 5486Number of Blocks: 57345Av. Block Size: 1800Tree Height: 36Statistics for IndexedFreeLists:--------------------------------Total Free Space: 371324Max Chunk Size: 254Number of Blocks: 8591 &lt;---- High fragmentationAv. Block Size: 43free=103595484 frag=1.0000 &lt;---- High fragmentationBefore GC:Statistics for BinaryTreeDictionary:------------------------------------Total Free Space: 0Max Chunk Size: 0Number of Blocks: 0Tree Height: 0Statistics for IndexedFreeLists:--------------------------------Total Free Space: 0Max Chunk Size: 0Number of Blocks: 0free=0 frag=0.000010628.168: [ParNew (promotion failed)Desired survivor size 9830400 bytes, new threshold 1 (max 1)- age 1: 4770440 bytes, 4770440 total: 121348K-&gt;122157K(134400K), 0.4263254 secs]10628,594: [CMS10630.887: [CMS-concurrent-mark: 7.286/8.682 secs] [Times: user=14.81 sys=0.34, real=8.68 secs] (concurrent mode failure): 1698044K-&gt;625427K(2099200K), 17.1365396 secs] 1815815K-&gt;625427K(2233600K), [CMS Perm : 186942K-&gt;180711K(409600K)]After GC:Statistics for BinaryTreeDictionary:------------------------------------Total Free Space: 377269492Max Chunk Size: 377269492Number of Blocks: 1Av. Block Size: 377269492Tree Height: 1Statistics for IndexedFreeLists:--------------------------------Total Free Space: 0Max Chunk Size: 0Number of Blocks: 0free=377269492 frag=0.0000After GC:Statistics for BinaryTreeDictionary:------------------------------------Total Free Space: 0Max Chunk Size: 0Number of Blocks: 0Tree Height: 0Statistics for IndexedFreeLists:--------------------------------Total Free Space: 0Max Chunk Size: 0Number of Blocks: 0free=0 frag=0.0000, 17.5645589 secs] [Times: user=17.82 sys=0.06, real=17.57 secs]Heap after GC invocations=7431 (full 25):par new generation total 134400K, used 0K [0x53000000, 0x5c600000, 0x5c600000)eden space 115200K, 0% used [0x53000000, 0x53000000, 0x5a080000)from space 19200K, 0% used [0x5b340000, 0x5b340000, 0x5c600000)to space 19200K, 0% used [0x5a080000, 0x5a080000, 0x5b340000)concurrent mark-sweep generation total 2099200K, used 625427K [0x5c600000, 0xdc800000, 0xdc800000)concurrent-mark-sweep perm gen total 409600K, used 180711K [0xdc800000, 0xf5800000, 0xfbc00000)&#125; Total time for which application threads were stopped: 17.5730653 seconds 2. Other OS activities happening at the time of GCSometimes the OS activities such as the swap space or networking activity happening at the time when GC is taking place can make the GC pauses last much longer. These pauses can be of the order of few seconds to some minutes. If your system is configured to use swap space, Operating System may move inactive pages of memory of the JVM process to the swap space, to free up memory for the currently active process which may be the same process or a different process on the system. Swapping is very expensive as it requires disk accesses which are much slower as compared to the physical memory access. So, if during a garbage collection the system needs to perform swapping, the GC would seem to run for a very long time. Following is the log of a young generation collection that lasts for 29.47 seconds.12345678&#123;Heap before GC invocations=132 (full 0):par new generation total 2696384K, used 2696384K [0xfffffffc20010000, 0xfffffffce0010000, 0xfffffffce0010000)eden space 2247040K, 100% used [0xfffffffc20010000, 0xfffffffca9270000, 0xfffffffca9270000)from space 449344K, 100% used [0xfffffffca9270000, 0xfffffffcc4940000, 0xfffffffcc4940000)to space 449344K, 0% used [0xfffffffcc4940000, 0xfffffffcc4940000, 0xfffffffce0010000)concurrent mark-sweep generation total 9437184K, used 1860619K [0xfffffffce0010000, 0xffffffff20010000, 0xffffffff20010000)concurrent-mark-sweep perm gen total 1310720K, used 511451K [0xffffffff20010000, 0xffffffff70010000, 0xffffffff70010000)2013-07-17T03:58:06.601-0700: 51522.120: [GC Before GC: : 2696384K-&gt;449344K(2696384K), 29.4779282 secs] 4557003K-&gt;2326821K(12133568K) ,29.4795222 secs] [Times: user=915.56 sys=6.35, real=29.48 secs] Corresponding ‘vmstat’ output at 03:58:123456kthr memory page disk faults cpur b w swap free re mf pi po fr de sr s0 s1 s2 s3 in sy cs us sy id20130717_035806 0 0 0 77611960 94847600 55 266 0 0 0 0 0 0 0 0 0 3041 2644 2431 44 8 4820130717_035815 0 0 0 76968296 94828816 79 324 0 18 18 0 0 0 0 1 0 3009 3642 2519 59 13 2820130717_035831 1 0 0 77316456 94816000 389 2848 0 7 7 0 0 0 0 2 0 40062 78231 61451 42 6 5320130717_035841 2 0 0 77577552 94798520 115 591 0 13 13 0 0 13 12 1 0 4991 8104 5413 2 0 98 This minor GC takes around 29 secs to complete. The corresponding vmstat output shows that the available swap space drops down by ~600mb during this period. That means during this garbage collection some pages from the RAM were moved out to the swap space, not necessarily by the same process running on the system. From the above, it is clear that the physical memory available on the system is not enough for all the processes running on the system. The way to resolve this is to run fewer processes or if possible, add more RAM to increase the physical memory of the system. In the case above, the specified maximum tenured generation size is set as 9G and out of that only 1.8G is occupied. So it makes sense to reduce the heap size to lower the memory pressure on the physical memory so as to avoid or minimize the swapping activity. Apart from swapping, we should monitor if there is any i/o or network activity happening during the long GC pauses. These can be monitored using iostat and netstat tools. It is also helpful to see the CPU statistics with the mpstat tool to figure out if enough CPU resources were available during the GC pauses. 3. Insufficient heap sizeIf the application footprint is larger than the maximum heap space that we have specified for the JVM, it results in frequent collections. Due to the insufficient heap space, the allocation requests fail and the JVM needs to invoke garbage collections in an attempt to reclaim space for the allocations. But since it cannot claim much space with each collection, subsequent allocation failures result in more GC invocations. These frequent Full GCs cause long pauses in the application run. For example, in the following case, the permanent generation is almost full and the allocation attempts into the permanent generation are failing, triggering the Full GCs.12166687.013: [Full GC [PSYoungGen: 126501K-&gt;0K(922048K)] [PSOldGen: 2063794K-&gt;1598637K(2097152K)] 2190295K-&gt;1598637K(3019200K) [PSPermGen: 165840K-&gt;164249K(166016K)], 6.8204928 secs] [Times: user=6.80 sys=0.02, real=6.81 secs]166699.015: [Full GC [PSYoungGen: 125518K-&gt;0K(922048K)] [PSOldGen: 1763798K-&gt;1583621K(2097152K)] 1889316K-&gt;1583621K(3019200K) [PSPermGen: 165868K-&gt;164849K(166016K)], 4.8204928 secs] [Times: user=4.80 sys=0.02, real=4.81 secs] Similarly, the frequent Full GCs can occur if there is insufficient space in the tenured generation for the allocations or promotions. The solution for these long pauses is to identify the average footprint of the application and then specify the heap size accordingly. 4. Bug in the JVMSometimes these long pauses could be due to a bug in the JVM. For example, due to the following bugs in the JVM, Java applications may face long GC pauses.1234567891011126459113: CMS+ParNew: wildly different ParNew pause times depending on heap shape caused by allocation spread fixed in JDK 6u1 and 76572569: CMS: consistently skewed work distribution indicated in (long) re-mark pauses fixed in JDK 6u4 and 76631166: CMS: better heuristics when combatting fragmentation fixed in JDK 6u21 and 76999988: CMS: Increased fragmentation leading to promotion failure after CR#6631166 got implemented fixed in JDK 6u25 and 76683623: G1: use logarithmic BOT code such as used by other collectors fixed in JDK 6u14 and 76976350: G1: deal with fragmentation while copying objects during GC fixed in JDK 8 If you are running with a JVM version affected with these bugs, please upgrade to the version where these bugs are fixed. 5. Explicit System GCsCheck if there are any explicit System GCs happening. Requests to invoke these System GCs which are stop-the-world Full GCs could be coming from the System.gc() calls from some class in the application or from a some third party module. These explicit System GCs too can cause very long pauses. 164638.058: [Full GC (System) [PSYoungGen: 22789K-&gt;0K(992448K)] [PSOldGen: 1645508K-&gt;1666990K(2097152K)] 1668298K-&gt;1666990K(3089600K) [PSPermGen: 164914K-&gt;164914K(166720K)], 5.7499132 secs] [Times: user=5.69 sys=0.06, real=5.75 secs] If you are using RMI and are observing explicit Full GCs on a regular interval, then these are coming from the RMI implementation that triggers System.gc() on a regular interval. This interval can be configured using the following system properties: -Dsun.rmi.dgc.server.gcInterval=n-Dsun.rmi.dgc.client.gcInterval=n The default value for these properties in JDK 1.4.2 and 5.0 is 60000 milliseconds, and 3600000 milliseconds in JDK 6 and later releases. If you want to disable the explicit Full GCs invoked using System.gc(), run the application with -XX:+DisableExplicitGC JVM option. How to approach the problem Collect GC logs with -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps and -XX:+PrintGCApplicationStoppedTime. In case of the CMS collector, add option -XX:PrintFLSStatistics=2 as well. The GC logs can give us details on the nature and the frequency of the GC pauses i.e. they can provide answers to the questions like - are the long GC pauses occurring during young collections or old collections, and how frequently those collections are encountering long pauses. Monitor the overall health of the system using OS tools like vmstat, iostat, netstat and mpstat etc. on Solaris and Linux platforms, and tools like Process Monitor and Task Manager on the Windows operating system. Use GCHisto tool to visually analyze the GC Logs and figure out which GCs are taking long time and if there is a pattern in the occurrence of these collections. Try to see from the GC logs if there are any signs of fragmentation in the Java Heap space. Monitor if the specified Heap size is enough to contain the footprint of the application. Check if you are running with a JVM that has a known bug related to the long GC pauses and then upgrade if that bug is fixed in a later version. 总结：长时间停顿问题的排查及解决首先需要一定的信息和方法论： 详细的 GC 日志借助 Linux 平台下的 iostat、vmstat、netstat、mpstat 等命令监控系统情况使用 GCHisto 这个 GC 图形用户界面工具，可以统计出 Minor GC 及 Full GC 频率及时长分布，可参考:http://blog.csdn.net/wenniuwuren/article/details/50760259查看 GC 日志中是否出现了上述的典型内存异常问题（promotion failed, concurrent mode failure），整体来说把上述两个典型内存异常情况控制在可接受的发生频率即可，对 CMS 碎片问题来说杜绝以上问题似乎不太可能，只能靠 G1 来解决了是不是 JVM 本身的 bug 导致的如果程序没问题，参数调了几次还是不能解决，可能说明流量太大，需要加机器把压力分散到更多 JVM 上 原谅地址：https://blogs.oracle.com/poonam/entry/troubleshooting_long_gc_pauseshttp://www.importnew.com/22886.html","tags":[{"name":"jvm","slug":"jvm","permalink":"http://willxue.top/tags/jvm/"},{"name":"调优","slug":"调优","permalink":"http://willxue.top/tags/调优/"}]},{"title":"缓存策略优化-缓存穿透","date":"2016-12-28T03:05:15.000Z","path":"2016/12/28/缓存策略优化-缓存穿透/","text":"缓存介绍 在高并发多用户的系统中常常会使用缓存来提升读写性能 常见的如memcached, redis, 内存缓存等 现象 某产品上线后不久，服务报警，看日志发现有sql的timeout报错，具体表现为： 页面许多逻辑超时、出错 db所在机器load较高，dba经查为大量相同的sql在反复执行 定位取应用服务的jstack 参考我之前的blog，stack dump文件用stackAnalysis工具分析，发现有大量的线程在做同一个事情：123456789101112131415161718192021222324252627282930313233343536373839404142434445464740 threads at (state = RUNNABLE,locks_locked = [0x0000000725b33848, 0x0000000725b338f0, 0x0000000737ff37d0, 0x0000000737f88f08, 0x0000000737f817c8, 0x00000007fc8ba580, 0x0000000725d8e638, 0x0000000725d8e6e0, 0x0000000738274490, 0x0000000725b5f720, 0x0000000725b5f7c8, 0x00000007384c03f8, 0x00000007231683a8, 0x0000000723168450, 0x0000000731980608, 0x0000000725d27ab8, 0x0000000725d2fcd8, 0x00000007384b16c8, 0x0000000723221798, 0x00000007232299c0, 0x000000072efb1228, 0x00000007005b70c0, 0x00000007005aff10, 0x0000000738321660, 0x00000007318cb948, 0x00000007318c4780, 0x0000000737c7de70, 0x0000000725a02d30, 0x0000000725a02dd8, 0x00000007fc8f8b60, 0x00000007232918f8, 0x000000072329db00, 0x000000073186ee08, 0x0000000725b7b928, 0x0000000725b7bb98, 0x0000000738066408, 0x00000007230a6ef8, 0x00000007230a0160, 0x0000000738191a18, 0x0000000737f619e8, 0x0000000737f5a6d8, 0x00000007fc8b9518, 0x0000000725ba54d0, 0x0000000725ba5578, 0x0000000738239a40, 0x0000000725e885c0, 0x0000000725e810e8, 0x00000007b24ac378, 0x00000007230c47e8, 0x00000007230c4890, 0x0000000731907c58, 0x00000007005345a0, 0x000000070052d098, 0x0000000731a6d400, 0x00000007231879f8, 0x0000000723187aa0, 0x000000073846aa20, 0x00000007231e7128, 0x00000007231e71d0, 0x0000000731958f38, 0x00000007231b2500, 0x00000007231b25a8, 0x00000007fc8f8dc0, 0x0000000725e1af28, 0x0000000725e1afd0, 0x0000000738323388, 0x00000007319ad368, 0x00000007319a6588, 0x00000007384894f0, 0x00000007318b8af8, 0x00000007318b1ba8, 0x00000007380c9908, 0x0000000725c5e478, 0x0000000725c5e520, 0x0000000738256338, 0x00000007230c7cd0, 0x00000007230b9440, 0x000000072e8c7810, 0x0000000725dcd8d0, 0x0000000725dc66d8, 0x0000000732c2df18, 0x00000007232425a0, 0x0000000723242648, 0x0000000732c31da0, 0x0000000731a4fd78, 0x0000000731a4fe20, 0x0000000738139a10, 0x0000000725cda198, 0x0000000725cda240, 0x0000000738066638, 0x0000000702b936b8, 0x0000000702b929a0, 0x00000007384893f0, 0x00000007230f9150, 0x00000007230f91f8, 0x0000000738036fc8, 0x000000073198d218, 0x000000073198d2c0, 0x00000007384710c8, 0x00000007231b0bf0, 0x00000007231b0c98, 0x00000007fc8bdea8, 0x00000007318a5808, 0x000000073189e0c8, 0x0000000731870018, 0x0000000723279d10, 0x0000000723279db8, 0x0000000738471170, 0x000000072e8fabd8, 0x000000072e8f8af8, 0x0000000732c51a38, 0x00000007319c69a8, 0x00000007319b9238, 0x0000000737fd5758, 0x0000000725b0c488, 0x0000000725b0c530, 0x00000007381f44a0, 0x0000000731a095b8, 0x0000000731a09660, 0x0000000735cbb2b0]) :\"http-bio-*-exec-*\" daemon prio=* tid=******** nid=******** runnable [********] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.read(SocketInputStream.java:129) at com.mysql.jdbc.util.ReadAheadInputStream.fill(ReadAheadInputStream.java:114) at com.mysql.jdbc.util.ReadAheadInputStream.readFromUnderlyingStreamIfNecessary(ReadAheadInputStream.java:161) at com.mysql.jdbc.util.ReadAheadInputStream.read(ReadAheadInputStream.java:189) - locked &lt;********&gt; (a com.mysql.jdbc.util.ReadAheadInputStream) at com.mysql.jdbc.MysqlIO.readFully(MysqlIO.java:3014) at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3467) at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3456) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3997) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2468) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2629) at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2719) - locked &lt;********&gt; (a com.mysql.jdbc.JDBC4Connection) at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2155) - locked &lt;********&gt; (a com.mysql.jdbc.JDBC4Connection) at com.mysql.jdbc.PreparedStatement.execute(PreparedStatement.java:1379) - locked &lt;********&gt; (a com.mysql.jdbc.JDBC4Connection) at com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.execute(NewProxyPreparedStatement.java:67) at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:56) at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:70) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:57) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:259) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:132) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:105) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:81) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:104) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:98) at sun.reflect.GeneratedMethodAccessor30.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:358) at com.sun.proxy.$Proxy18.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:198) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:114) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:58) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:43) at com.sun.proxy.$Proxy46.selectAllValidActivityPush(Unknown Source) at com.xxxx.xxxx.module.inbox.InboxAgent.selectActivityPush(InboxAgent.java:612) at com.xxxx.xxxx.service.SystemMessageService.getActivityPushMessage(SystemMessageService.java:975) at com.xxxx.xxxx.service.login.logic.impl.LogicLoginServiceImpl.updateLoginUser(LogicLoginServiceImpl.java:438) at com.xxxx.xxxx.service.login.logic.impl.LogicLoginServiceImpl.updateLoginUser(LogicLoginServiceImpl.java:374) at com.xxxx.xxxx.web.controller.login.LoginController.login(LoginController.java:119) 可以看到有40个线程在等待db的数据返回，结合堆栈，基本可以定位到有问题的代码逻辑了 分析仔细分析对应代码逻辑，可发现有如下的缓存策略：12345678910Object getObject() &#123; o = getFromCache() if(o == null)&#123; o = getFromDb() if(o != null) &#123; setToCache(o) &#125; &#125; return o;&#125; 从上面看貌似没有问题，但仔细分析会发现当getFromDb()返回null即数据库中并不存在相关数据时，每一个线程都会去执行getFromDb()这个方法，每个请求都会穿透到db上 当用户请求较大时，对数据库的压力会非常大【上面的stack仅为多台应用web中的一台】 解决思路当数据库中无数据时，可以在缓存中放一个无效的对象表明“数据为空，不需要到db中查询了”，如下： 12345678910111213Object getObject() &#123; o = getFromCache(key) if(o == null)&#123; o = getFromDb() if(o != null) &#123; setToCache(key, o) &#125; else &#123; setToCache(key, invalidObject) &#125; &#125; return o == invalidObject ? null : o;&#125; 更进一步，上面的getFromDb()逻辑仍有可能会被多个线程同时操作，可以视业务场景而加上分布式锁的逻辑：12345678910111213141516171819Object getObject() &#123; o = getFromCache(key) if(o == null)&#123; try &#123; if(cache.lock(key)) &#123; o = getFromDb() if(o != null) &#123; setToCache(key, o) &#125; else &#123; setToCache(key, invalidObject) &#125; &#125; &#125; finally &#123; cache.unlock(key); &#125; &#125; return o == invalidObject ? null : o;&#125; 延伸我们在用缓存的时候，不管是Redis或者Memcached，基本上会通用遇到以下三个问题： 缓存穿透 存并发 缓存失效 其实上面是对缓存加锁，考虑缓存并发的问题，只不过利用锁的方式，会造成部分请求等待。 ###缓存失效引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。 那如何解决这些问题呢？其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 思考及建议 多线程思维：每一行代码都要考虑其会被多个线程高并发的执行 抠门思维：每一行代码，尤其每一个网络操作（cache或db），都要考虑是否可以节省下来，或者将多个操作合并为一个操作 批量思维：多个动作是否可以一次完成。举个例子：去菜市场买菜大家都会一次把五种菜全买回，而不是买一次菜去菜市场一次。coding为什么不也这样呢？ 每个逻辑都要谨慎思考，任何疏忽都可能会把线上搞死，服务宕机，造成严重后果 原文链接： 简书作者http://www.jianshu.com/p/d96906140199","tags":[{"name":"缓存","slug":"缓存","permalink":"http://willxue.top/tags/缓存/"}]},{"title":"Git多个SSH KEY的管理简易版","date":"2016-12-27T08:57:51.000Z","path":"2016/12/27/Git多个SSH-KEY的管理简易版/","text":"ssh-keygen -t rsa -C “painarthur@gmail.com” -f ~/.ssh/id_rsa_github_painarthurssh-keygen -t rsa -C “paincupid@hotmail.com” -f ~/.ssh/id_rsa_github_paincupidssh-keygen -t rsa -C “paincupid@hotmail.com” -f ~/.ssh/id_rsa_oschina 添加 ssh-add ~/.ssh/id_rsa_github_painarthurssh-add ~/.ssh/id_rsa_github_paincupidssh-add ~/.ssh/id_rsa_oschina 如果执行ssh-add时提示”Could not open a connection to your authentication agent”，可以现执行命令： $ ssh-agent bash 在bash下的话直接touch config 新建文件config即可，用NotePad之类的文本工具打开config文件123456789101112131415# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_github_painarthur# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_github_paincupid# oschinaHost git.oschina.netHostName git.oschina.netPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_oschina 测试 ssh -t git@github.comssh -T git@git.oschina.net 上面第二个github的帐号没试，貌似相同的网站下不同的帐号，还需要其它处理。请参考：http://www.cnblogs.com/xjnotxj/p/5845574.html第一个和第三个没有问题，亲测","tags":[{"name":"git","slug":"git","permalink":"http://willxue.top/tags/git/"}]},{"title":"Top 10 Easy Performance Optimisations in Java","date":"2016-12-27T07:08:33.000Z","path":"2016/12/27/Top-10-Easy-Performance-Optimisations-in-Java/","text":"Top 10 Easy Performance Optimisations in JavaThere has been a lot of hype about the buzzword “web scale“, and people are going through lengths of reorganising their application architecture to get their systems to “scale”. But what is scaling, and how can we make sure that we can scale? Different aspects of scalingThe hype mentioned above is mostly about scaling load, i.e. to make sure that a system that works for 1 user will also work well for 10 users, or 100 users, or millions. Ideally, your system is as “stateless” as possible such that the few pieces of state that really remain can be transferred and transformed on any processing unit in your network. When load is your problem, latency is probably not, so it’s OK if individual requests take 50-100ms. This is often also referred to as scaling out An entirely different aspect of scaling is about scaling performance, i.e. to make sure that an algorithm that works for 1 piece of information will also work well for 10 pieces, or 100 pieces, or millions. Whether this type of scaling is feasible is best described by Big O Notation. Latency is the killer when scaling performance. You want to do everything possible to keep all calculation on a single machine. This is often also referred to as scaling up If there was anything like free lunch (there isn’t), we could indefinitely combine scaling up and out. Anyway, today, we’re going to look at some very easy ways to improve things on the performance side.Big O Notation Java 7’s ForkJoinPool as well as Java 8’s parallel Stream help parallelising stuff, which is great when you deploy your Java program onto a multi-core processor machine. The advantage of such parallelism compared to scaling across different machines on your network is the fact that you can almost completely eliminate latency effects, as all cores can access the same memory. But don’t be fooled by the effect that parallelism has! Remember the following two things: Parallelism eats up your cores. This is great for batch processing, but a nightmare for asynchronous servers (such as HTTP). There are good reasons why we’ve used the single-thread servlet model in the past decades. So parallelism only helps when scaling up. Parallelism has no effect on your algorithm’s Big O Notation. If your algorithm is O(n log n), and you let that algorithm run on c cores, you will still have an O(n log n / c) algorithm, as c is an insignificant constant in your algorithm’s complexity. You will save wall-clock time, but not reduce complexity! The best way to improve performance, of course, is by reducing algorithm complexity. The killer is achieve O(1) or quasi-O(1), of course, for instance a HashMap lookup. But that is not always possible, let alone easy. If you cannot reduce your complexity, you can still gain a lot of performance if you tweak your algorithm where it really matters, if you can find the right spots. Assume the following visual representation of an algorithm: The overall complexity of the algorithm is O(N3), or O(N x O x P) if we want to deal with individual orders of magnitude. However, when profiling this code, you might find a funny scenario: On your development box, the left branch (N -&gt; M -&gt; Heavy operation) is the only branch that you can see in your profiler, because the values for O and P are small in your development sample data. On production, however, the right branch (N -&gt; O -&gt; P -&gt; Easy operation or also N.O.P.E.) is really causing trouble. Your operations team might have figured this out using AppDynamics, or DynaTrace, or some similar software. Without production data, you might quickly jump to conclusions and optimise the “heavy operation”. You ship to production and your fix has no effect. There are no golden rules to optimisation apart from the facts that: A well-designed application is much easier to optimise Premature optimisation will not solve any performance problems, but make your application less well-designed, which in turn makes it harder to be optimised Enough theory. Let’s assume that you have found the right branch to be the issue. It may well be that a very easy operation is blowing up in production, because it is called lots and lots of times (if N, O, and P are large). Please read this article in the context of there being a problem at the leaf node of an inevitable O(N3) algorithm. These optimisations won’t help you scale. They’ll help you save your customer’s day for now, deferring the difficult improvement of the overall algorithm until later! Here are the top 10 easy performance optimisations in Java: 1. Use StringBuilderThis should be your default in almost all Java code. Try to avoid the + operator. Sure, you may argue that it is just syntax sugar for a StringBuilder anyway, as in:1String x = \"a\" + args.length + \"b\"; … which compiles to 1234567891011 0 new java.lang.StringBuilder [16] 3 dup 4 ldc &lt;String \"a\"&gt; [18] 6 invokespecial java.lang.StringBuilder(java.lang.String) [20] 9 aload_0 [args]10 arraylength11 invokevirtual java.lang.StringBuilder.append(int) : java.lang.StringBuilder [23]14 ldc &lt;String \"b\"&gt; [27]16 invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [29]19 invokevirtual java.lang.StringBuilder.toString() : java.lang.String [32]22 astore_1 [x] But what happens, if later on, you need to amend your String with optional parts?12345String x = \"a\" + args.length + \"b\";if (args.length == 1) x = x + args[0]; You will now have a second StringBuilder, that just needlessly consumes memory off your heap, putting pressure on your GC. Write this instead:123456StringBuilder x = new StringBuilder(\"a\");x.append(args.length);x.append(\"b\");if (args.length == 1); x.append(args[0]); Takeaway In the above example, it is probably completely irrelevant if you’re using explicit StringBuilder instances, or if you rely on the Java compiler creating implicit instances for you. But remember, we’re in the N.O.P.E. branch. Every CPU cycle that we’re wasting on something as stupid as GC or allocating a StringBuilder‘s default capacity, we’re wasting N x O x P times. As a rule of thumb, always use a StringBuilder rather than the + operator. And if you can, keep the StringBuilder reference across several methods, if your String is more complex to build. This is what jOOQ does when you generate a complex SQL statement. There is only one StringBuilder that “traverses” your whole SQL AST (Abstract Syntax Tree) And for crying out loud, if you still have StringBuffer references, do replace them by StringBuilder. You really hardly ever need to synchronize on a string being created. 2. Avoid regular expressions 避免使用正则表达式，尽量使用Apache Commons Lang instead替代Regular expressions are relatively cheap and convenient. But if you’re in the N.O.P.E. branch, they’re about the worst thing you can do. If you absolutely must use regular expressions in computation-intensive code sections, at least cache the Pattern reference instead of compiling it afresh all the time:12static final Pattern HEAVY_REGEX = Pattern.compile(\"(((X)*Y)*Z)*\"); But if your regular expression is really silly like1String[] parts = ipAddress.split(\"\\\\.\"); … then you really better resort to ordinary char[] or index-based manipulation. For example this utterly unreadable loop does the same thing:123456789101112int length = ipAddress.length();int offset = 0;int part = 0;for (int i = 0; i &lt; length; i++) &#123; if (i == length - 1 || ipAddress.charAt(i + 1) == '.') &#123; parts[part] = ipAddress.substring(offset, i + 1); part++; offset = i + 2; &#125;&#125; … which also shows why you shouldn’t do any premature optimisation. Compared to the split() version, this is unmaintainable. Challenge: The clever ones among your readers might find even faster algorithms. Takeaway Regular expressions are useful, but they come at a price. If you’re deep down in a N.O.P.E. branch, you must avoid regular expressions at all costs. Beware of a variety of JDK String methods, that use regular expressions, such as String.replaceAll(), or String.split(). Use a popular library like Apache Commons Lang instead, for your String manipulation. 3. Do not use iterator()Now, this advice is really not for general use-cases, but only applicable deep down in a N.O.P.E. branch. Nonetheless, you should think about it. Writing Java-5 style foreach loops is convenient. You can just completely forget about looping internals, and write:123for (String value : strings) &#123; // Do something useful here&#125; However, every time you run into this loop, if strings is an Iterable, you will create a new Iterator instance. If you’re using an ArrayList, this is going to be allocating an object with 3 ints on your heap:12345private class Itr implements Iterator&lt;E&gt; &#123; int cursor; int lastRet = -1; int expectedModCount = modCount; // ... Instead, you can write the following, equivalent loop and “waste” only a single int value on the stack, which is dirt cheap:12345int size = strings.size();for (int i = 0; i &lt; size; i++) &#123; String value : strings.get(i); // Do something useful here&#125; … or, if your list doesn’t really change, you might even operate on an array version of it:123for (String value : stringArray) &#123; // Do something useful here&#125; Takeaway Iterators, Iterable, and the foreach loop are extremely useful from a writeability and readability perspective, as well as from an API design perspective. However, they create a small new instance on the heap for each single iteration. If you run this iteration many many times, you want to make sure to avoid creating this useless instance, and write index-based iterations instead. Discussion Some interesting disagreement about parts of the above (in particular replacing Iterator usage by access-by-index) has been discussed on Reddit here. 4. Don’t call that methodSome methods are simple expensive. In our N.O.P.E. branch example, we don’t have such a method at the leaf, but you may well have one. Let’s assume your JDBC driver needs to go through incredible trouble to calculate the value of ResultSet.wasNull(). Your homegrown SQL framework code might look like this:12345678910if (type == Integer.class) &#123; result = (T) wasNull(rs, Integer.valueOf(rs.getInt(index)));&#125;// And then...static final &lt;T&gt; T wasNull(ResultSet rs, T value)throws SQLException &#123; return rs.wasNull() ? null : value;&#125; This logic will now call ResultSet.wasNull() every time you get an int from the result set. But the getInt() contract reads: Returns: the column value; if the value is SQL NULL, the value returned is 0 Thus, a simple, yet possibly drastic improvement to the above would be: 12345678static final &lt;T extends Number&gt; T wasNull( ResultSet rs, T value)throws SQLException &#123; return (value == null || (value.intValue() == 0 &amp;&amp; rs.wasNull())) ? null : value;&#125; So, this is a no-brainer: Takeaway Don’t call expensive methods in an algorithms “leaf nodes”, but cache the call instead, or avoid it if the method contract allows it. 5. Use primitives and the stack 使用基础类型和栈The above example is from jOOQ, which uses a lot of generics, and thus is forced to use wrapper types for byte, short, int, and long – at least before generics will be specialisable in Java 10 and project Valhalla. But you may not have this constraint in your code, so you should take all measures to replace:12// Goes to the heapInteger i = 817598; … by this:Stays on the stack1int i = 817598; Things get worse when you’re using arrays:123// Three heap objects!Integer[] i = &#123; 1337, 424242 &#125;; … by this:12// One heap object.int[] i = &#123; 1337, 424242 &#125;; Takeaway When you’re deep down in your N.O.P.E. branch, you should be extremely wary of using wrapper types. Chances are that you will create a lot of pressure on your GC, which has to kick in all the time to clean up your mess. A particularly useful optimisation might be to use some primitive type and create large, one-dimensional arrays of it, and a couple of delimiter variables to indicate where exactly your encoded object is located on the array. An excellent library for primitive collections, which are a bit more sophisticated than your average int[] is trove4j, which ships with LGPL. Exception There is an exception to this rule: boolean and byte have few enough values to be cached entirely by the JDK. You can write:12345Boolean a1 = true; // ... syntax sugar for:Boolean a2 = Boolean.valueOf(true);Byte b1 = (byte) 123; // ... syntax sugar for:Byte b2 = Byte.valueOf((byte) 123); The same is true for low values of the other integer primitive types, including char, short, int, long. But only if you’re auto-boxing them, or calling TheType.valueOf(), not when you call the constructor! Never call the constructor on wrapper types, unless you really want a new instance This fact can also help you write a sophisticated, trolling April Fool’s joke for your co-workers Off heap Of course, you might also want to experiment with off-heap libraries, although they’re more of a strategic decision, not a local optimisation. An interesting article on that subject by Peter Lawrey and Ben Cotton is: OpenJDK and HashMap… Safely Teaching an Old Dog New (Off-Heap!) Tricks 6. Avoid recursionModern functional programming languages like Scala encourage the use of recursion, as they offer means of optimising tail-recursing algorithms back into iterative ones. If your language supports such optimisations, you might be fine. But even then, the slightest change of algorithm might produce a branch that prevents your recursion from being tail-recursive. Hopefully the compiler will detect this! Otherwise, you might be wasting a lot of stack frames for something that might have been implemented using only a few local variables. Takeaway There’s not much to say about this apart from: Always prefer iteration over recursion when you’re deep down the N.O.P.E. branch 7. Use entrySet()When you want to iterate through a Map, and you need both keys and values, you must have a very good reason to write the following:123for (K key : map.keySet()) &#123; V value : map.get(key);&#125; … rather than the following:1234for (Entry&lt;K, V&gt; entry : map.entrySet()) &#123; K key = entry.getKey(); V value = entry.getValue();&#125; When you’re in the N.O.P.E. branch, you should be wary of maps anyway, because lots and lots of O(1) map access operations are still lots of operations. And the access isn’t free either. But at least, if you cannot do without maps, use entrySet() to iterate them! The Map.Entry instance is there anyway, you only need to access it. Takeaway Always use entrySet() when you need both keys and values during map iteration. 8. Use EnumSet or EnumMapThere are some cases where the number of possible keys in a map is known in advance – for instance when using a configuration map. If that number is relatively small, you should really consider using EnumSet or EnumMap, instead of regular HashSet or HashMap instead. This is easily explained by looking at EnumMap.put():12345678private transient Object[] vals;public V put(K key, V value) &#123; // ... int index = key.ordinal(); vals[index] = maskNull(value); // ...&#125; The essence of this implementation is the fact that we have an array of indexed values rather than a hash table. When inserting a new value, all we have to do to look up the map entry is ask the enum for its constant ordinal, which is generated by the Java compiler on each enum type. If this is a global configuration map (i.e. only one instance), the increased access speed will help EnumMap heavily outperform HashMap, which may use a bit less heap memory, but which will have to run hashCode() and equals() on each key. Takeaway Enum and EnumMap are very close friends. Whenever you use enum-like structures as keys, consider actually making those structures enums and using them as keys in EnumMap. 9. Optimise your hashCode() and equals() methodsIf you cannot use an EnumMap, at least optimise your hashCode() and equals() methods. A good hashCode() method is essential because it will prevent further calls to the much more expensive equals() as it will produce more distinct hash buckets per set of instances. In every class hierarchy, you may have popular and simple objects. Let’s have a look at jOOQ’s org.jooq.Table implementations. The simplest and fastest possible implementation of hashCode() is this one:12345678910// AbstractTable, a common Table base implementation:@Overridepublic int hashCode() &#123; // [#1938] This is a much more efficient hashCode() // implementation compared to that of standard // QueryParts return name.hashCode();&#125; … where name is simply the table name. We don’t even consider the schema or any other property of the table, as the table names are usually distinct enough across a database. Also, the name is a string, so it has already a cached hashCode() value inside. The comment is important, because AbstractTable extends AbstractQueryPart, which is a common base implementation for any AST (Abstract Syntax Tree) element. The common AST element does not have any properties, so it cannot make any assumptions an optimised hashCode() implementation. Thus, the overridden method looks like this:12345678910// AbstractQueryPart, a common AST element// base implementation:@Overridepublic int hashCode() &#123; // This is a working default implementation. // It should be overridden by concrete subclasses, // to improve performance return create().renderInlined(this).hashCode();&#125; In other words, the whole SQL rendering workflow has to be triggered to calculate the hash code of a common AST element. Things get more interesting with equals()12345678910111213141516171819202122// AbstractTable, a common Table base implementation:@Overridepublic boolean equals(Object that) &#123; if (this == that) &#123; return true; &#125; // [#2144] Non-equality can be decided early, // without executing the rather expensive // implementation of AbstractQueryPart.equals() if (that instanceof AbstractTable) &#123; if (StringUtils.equals(name, (((AbstractTable&lt;?&gt;) that).name))) &#123; return super.equals(that); &#125; return false; &#125; return false;&#125; First thing: Always (not only in a N.O.P.E. branch) abort every equals() method early, if: this == argument this “incompatible type” argument Note that the latter condition includes argument == null, if you’re using instanceof to check for compatible types. We’ve blogged about this before in 10 Subtle Best Practices when Coding Java. Now, after aborting comparison early in obvious cases, you might also want to abort comparison early when you can make partial decisions. For instance, the contract of jOOQ’s Table.equals() is that for two tables to be considered equal, they must be of the same name, regardless of the concrete implementation type. For instance, there is no way these two items can be equal: com.example.generated.Tables.MY_TABLE DSL.tableByName(“MY_OTHER_TABLE”) If the argument cannot be equal to this, and if we can check that easily, let’s do so and abort if the check fails. If the check succeeds, we can still proceed with the more expensive implementation from super. Given that most objects in the universe are not equal, we’re going to save a lot of CPU time by shortcutting this method. some objects are more equal than others In the case of jOOQ, most instances are really tables as generated by the jOOQ source code generator, whose equals() implementation is even further optimised. The dozens of other table types (derived tables, table-valued functions, array tables, joined tables, pivot tables, common table expressions, etc.) can keep their “simple” implementation. 10. Think in sets, not in individual elementsLast but not least, there is a thing that is not Java-related but applies to any language. Besides, we’re leaving the N.O.P.E. branch as this advice might just help you move from O(N3) to O(n log n), or something like that. Unfortunately, many programmers think in terms of simple, local algorithms. They’re solving a problem step by step, branch by branch, loop by loop, method by method. That’s the imperative and/or functional programming style. While it is increasingly easy to model the “bigger picture” when going from pure imperative to object oriented (still imperative) to functional programming, all these styles lack something that only SQL and R and similar languages have: Declarative programming. In SQL (and we love it, as this is the jOOQ blog) you can declare the outcome you want to get from your database, without making any algorithmic implications whatsoever. The database can then take all the meta data available into consideration (e.g. constraints, keys, indexes, etc.) to figure out the best possible algorithm. In theory, this has been the main idea behind SQL and relational calculus from the beginning. In practice, SQL vendors have implemented highly efficient CBOs (Cost-Based Optimisers) only since the last decade, so stay with us in the 2010’s when SQL will finally unleash its full potential (it was about time!) But you don’t have to do SQL to think in sets. Sets / collections / bags / lists are available in all languages and libraries. The main advantage of using sets is the fact that your algorithms will become much much more concise. It is so much easier to write: SomeSet INTERSECT SomeOtherSet rather than:```java// Pre-Java 8Set result = new HashSet();for (Object candidate : someSet) if (someOtherSet.contains(candidate)) result.add(candidate); // Even Java 8 doesn’t really helpsomeSet.stream() .filter(someOtherSet::contains) .collect(Collectors.toSet()); ```Some may argue that functional programming and Java 8 will help you write easier, more concise algorithms. That’s not necessarily true. You can translate your imperative Java-7-loop into a functional Java-8 Stream collection, but you’re still writing the very same algorithm. Writing a SQL-esque expression is different. This… SomeSet INTERSECT SomeOtherSet … can be implemented in 1000 ways by the implementation engine. As we’ve learned today, perhaps it is wise to transform the two sets into EnumSet automatically, before running the INTERSECT operation. Perhaps we can parallelise this INTERSECT without making low-level calls to Stream.parallel() ConclusionIn this article, we’ve talked about optimisations done on the N.O.P.E. branch, i.e. deep down in a high-complexity algorithm. In our case, being the jOOQ developers, we have interest in optimising our SQL generation: Every query is generated only on a single StringBuilder Our templating engine actually parses characters, instead of using regular expressions We use arrays wherever we can, especially when iterating over listeners We stay clear of JDBC methods that we don’t have to call etc… jOOQ is at the “bottom of the food chain”, because it’s the (second-)last API that is being called by our customers’ applications before the call leaves the JVM to enter the DBMS. Being at the bottom of the food chain means that every line of code that is executed in jOOQ might be called N x O x P times, so we must optimise eagerly. Your business logic is not deep down in the N.O.P.E. branch. But your own, home-grown infrastructure logic may be (custom SQL frameworks, custom libraries, etc.) Those should be reviewed according to the rules that we’ve seen today. For instance, using Java Mission Control or any other profiler. Liked this article? If you can’t go and profile your application right now, you might enjoy reading any of these articles instead: 10 Subtle Mistakes When Using the Streams API 10 Things You Didn’t Know About Java 10 Subtle Best Practices when Coding Java 原文链接： https://blog.jooq.org/2015/02/05/top-10-easy-performance-optimisations-in-java/","tags":[{"name":"java优化","slug":"java优化","permalink":"http://willxue.top/tags/java优化/"}]},{"title":"hexo-github安装过程记录","date":"2016-12-23T14:32:39.000Z","path":"2016/12/23/hexo-github安装过程记录/","text":"一、准备工作npm镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）: 1.通过config命令 npm config set registry https://registry.npm.taobao.orgnpm info underscore （如果上面配置正确这个命令会有字符串response） 2.命令行指定npm –registry https://registry.npm.taobao.org info underscore 3.编辑 ~/.npmrc 加入下面内容registry = https://registry.npm.taobao.org 二、安装 npm install hexo-cli -g hexo init npm install hexo s 4000端口有没有被占用 netstat -an|findstr 4000 三、可能遇到的问题上述步骤完成后，hexo的配置已经基本完成，可以执行hexo server，然后访问localhost:4000查看效果。（hexo默认的端口号是4000，但是4000端口如果被其他进程占用的话，这时访问localhost:4000会得不到响应。如果你的电脑安装了福昕阅读器，就是他，没错，坑爹吧！！！！解决这个问题的方法是指定其他的端口hexo server -p 4099，访问localhost:4099）如果还不行，再试一下： 记住：是下面2个横杠哦1npm install hexo-server --save Q：如何卸载Hexo？A：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g。Q：如何安装旧版本Hexo？A：先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。 四、hexo官网文档https://hexo.io/zh-cn/docs/index.html 五、主题推荐三个主题: yilia主题 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia next主题 git clone https://github.com/iissnan/hexo-theme-next themes/next使用说明：http://theme-next.iissnan.com/getting-started.html#leanclound-page-views 大道至简主题123git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassantnpm install hexo-renderer-jade --savepm install hexo-renderer-sass --save 这个博客不错http://opiece.me/2016/03/12/concise-to-next/ 自动发布http://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/ 六、yml文件在线校验器www.yamllint.com 七、头像：http://chuantu.biz/t5/44/1482477270x1926756903.jpghttp://oj00y6um9.bkt.clouddn.com/Luffy.jpg 免费的图片上传网站：http://www1.freep.cn/http://www.chuantu.biz/upload.php 八、草稿相当于很多博客都有的“私密文章”功能。 $ hexo new draft “new draft” 如果你希望强行预览草稿，更改配置文件： render_drafts: true 或者，如下方式启动server： $ hexo server –drafts 下面这条命令可以把草稿变成文章，或者页面： $ hexo publish [layout] 域名绑定http://www.jianshu.com/p/863f3f2d1733 上传图片1、首先确认_config.yml中有： post_asset_folder: true 2、在blog要目录下，即_config.yml站点文件下，打开命令git bash,并执行：1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 3、即可在hexo generate时正确生成插入图片。1234_posts |- post1.md |_ post1 |- pic1.png 4、在md文件中插入图片时只需写 问题 “Deployer not found: github”1npm install hexo-deployer-git --save 九、hexo目录结构12345678910111213141516171819├── _config.yml // 主题配置文件├── languages // 多语言文件夹├── layout│ ├── archive.swig // 存档页模板│ ├── category.swig // 分类文章列表页模板│ ├── includes // 各页面共享的模板│ │ ├── layout.swig // 页面布局模板，其它的页面模板都是根据它扩展来的│ │ ├── pagination.swig // 翻页按钮模板│ │ └── recent-posts.swig // 文章列表模板│ ├── index.swig // 首页模板│ ├── page.swig // 页面详情页模板│ ├── post.swig // 文章详情页模板│ └── tag.swig // 标签文章列表页模板└── source ├── css │ └── theme.styl // 主题自定义 CSS 文件 ├── favicon.ico └── js └── theme.js // 主题 JavaScript 文件 十、git源文件和deploy文件分开的话。hexo两台电脑维护同一博客的大概流程： 在初始一台电脑上搭建hexo博客(搭建流程见github+hexo大概流程)，搭建完后上传本地的hexo到github或其他远程代码托管平台。（这里上传的是hexo所用到的东西，不用上传node_modules，public 这种自动生成的） 在第二台电脑上把hexo原始文件clone到本地 在第二台电脑上同样安装hexo用的东西（见github+hexo大概流程） 在第二台电脑上clone下来的代码中执行（不能执行hexo init） npm install 如果提示没有其它插件，则做相应的安装： 12345678910npm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save这个时候再重新生成静态文件，命令：hexo generate （或hexo g）启动本地服务器：hexo server （或hexo s） ———————————————-本地文件自己备一下：我用的是next主题 主站文件_config.yml：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: painArthur's blogsubtitle: Did you get what you want?description: A good life is one inspired by love and guided by knowledge.author: arthur.dy.leelanguage: zh-Hanstimezone:# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: coding #默认分类category_map: #分类别名 编程: coding 生活: lifetag_map: #标签别名 音乐: music 美文: beatiful article spring: spring 多线程: concurrent java: javaCore 工具: tool# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:paincupid/paincupid.github.io.git 主题_config.yml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico# Set default keywords (Use a comma to separate)keywords: \"Hexo, NexT\"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: false# Specify the date when the site was setupsince: 2016# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / archives: /archives #about: /about categories: /categories tags: /tags #search: /search #commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Musescheme: Mist#scheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: csdn: http://blog.csdn.net/paincupid oschina: https://git.oschina.net/paincupid# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwsome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: http://chuantu.biz/t5/44/1482477270x1926756903.jpg# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove# Blogrolls#links_title: Links#links_layout: block#links_layout: inline#links: #Title: http://example.com/# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 200# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: true per_page: true cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key#swiftype_key:# Baidu Analytics IDbaidu_analytics: 840d145f6ce561830c81a4c79487e67a# Duoshuo ShortNameduoshuo_shortname: painarthur# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.add_this_id: ra-5860e1dc2fe90e0e# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification: QGI59huOsh0Ym4WeP5tQOosSvbX5FzIoYdN8kysRx2I# Google Analyticsgoogle_analytics: UA-89476840-1# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics IDtencent_analytics: 60149125# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" hits_stats: \"$&#123;hits&#125; results found in $&#123;time&#125; ms\"#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0","tags":[{"name":"hexo","slug":"hexo","permalink":"http://willxue.top/tags/hexo/"},{"name":"github blog","slug":"github-blog","permalink":"http://willxue.top/tags/github-blog/"}]}]